# DE-HY25.09 WMI Event Subscription Persistence Detection 
id: DE-HY25.09
title: WMI Event Subscription Persistence Detection 
description: |
  Detects the creation of WMI permanent event subscriptions (Filter, Consumer, Binding triad) 
  via PowerShell, WMIC, or API, a stealthy fileless persistence technique
severity: High
status: draft
author: \m/
date_created: 2025-10-17
date_modified: 2025-10-17
tags:
  - clarifi_path: Windows/Endpoint/Persistence
  - tactic: Defense Evasion
  - tactic: Persistence
  - technique: Event Triggered Execution: WMI Event Subscription
  - technique: Windows Management Instrumentation
  - ATT&CK_ID: T1546.003 # Event Triggered Execution: WMI Event Subscription
  - ATT&CK_ID: T1047 # Windows Management Instrumentation
  - method: Signature/String-Match
  - method: Statistical/Baseline-Comparison
  - core_indicator: Event_WMI_Persistence
  - core_indicator: Cmd_Encoded
  - core_indicator: File_Persistence_Artifact
  - datasource: DeviceProcessEvents
  - datasource: DeviceEvents
  - datasource: DeviceFileEvents

logic:
  query: |

// WMI Event Subscription Persistence Detection 
// Detects WMI permanent event subscriptions via process activity and WMI operations

// Parameters
let LookbackWindow = 7d;
let CorrelationWindow = 5m;
let BaselineWindow = 90d;

// Legitimate WMI usage patterns (add more here during initial testing)
let LegitimateWMIProcesses = dynamic([
    "sccm.exe", "ccmexec.exe",           // SCCM/ConfigMgr
    "taniumclient.exe",                   // Tanium
    "splunkd.exe", "splunkforwarder.exe", // Splunk
    "msmpeng.exe", "msseces.exe",         // Windows Defender
    "veeam", "backup"                     // Backup software
]);

let LegitimateWMINamespaces = dynamic([
    "root\\ccm",           // SCCM
    "root\\SecurityCenter" // Windows Security Center
]);

// Suspicious consumer payloads (some of these can be removed for tuning but these are generally how the attack works)
let SuspiciousPayloads = dynamic([
    "powershell", "cmd.exe", "rundll32", "mshta", "wscript", "cscript",
    "regsvr32", "certutil", "bitsadmin", "msiexec",
    "-enc", "-e ", "IEX", "Invoke-Expression", "DownloadString",
    "http://", "https://", "ftp://"
]);

// Get baseline of WMI activity
let WMIBaseline = 
    DeviceProcessEvents
    | where TimeGenerated between (ago(BaselineWindow) .. ago(LookbackWindow))
    | where ProcessCommandLine has_any ("Register-WmiEvent", "Set-WmiInstance", "wmic /namespace")
    | summarize 
        BaselineCount = count(),
        BaselineInitiators = make_set(InitiatingProcessFileName)
    by DeviceName;

// Module 1: PowerShell-based WMI Event Subscription Creation
let PowerShellWMISubscription = 
    DeviceProcessEvents
    | where TimeGenerated >= ago(LookbackWindow)
    | where FileName in~ ("powershell.exe", "pwsh.exe")
    // Detect PowerShell WMI subscription cmdlets
    | where ProcessCommandLine has_any (
        "Register-WmiEvent",
        "Set-WmiInstance",
        "__EventFilter",
        "__EventConsumer", 
        "__FilterToConsumerBinding",
        "ActiveScriptEventConsumer",
        "CommandLineEventConsumer"
    )
    | extend
        IsFilterCreation = ProcessCommandLine has "__EventFilter",
        IsConsumerCreation = ProcessCommandLine has_any ("__EventConsumer", "CommandLineEventConsumer", "ActiveScriptEventConsumer"),
        IsBindingCreation = ProcessCommandLine has "__FilterToConsumerBinding",
        HasSuspiciousPayload = ProcessCommandLine has_any (SuspiciousPayloads),
        WMINamespace = extract(@"namespace[:\s]+([^\s;""']+)", 1, ProcessCommandLine),
        ConsumerPayload = extract(@"CommandLineTemplate[:\s]*=\s*[""']([^""']+)[""']", 1, ProcessCommandLine)
    | where IsFilterCreation or IsConsumerCreation or IsBindingCreation
    | extend
        DetectionMethod = "PowerShell-WMI-Cmdlet",
        WMIComponent = case(
            IsFilterCreation, "Filter",
            IsConsumerCreation, "Consumer", 
            IsBindingCreation, "Binding",
            "Unknown"
        )
    | project TimeGenerated, DeviceName, DetectionMethod, WMIComponent,
              ProcessCommandLine, ConsumerPayload, WMINamespace,
              InitiatingProcessFileName, AccountName, AccountDomain,
              HasSuspiciousPayload;

// Module 2: WMIC.exe-based WMI Event Subscription
let WMICSubscription =
    DeviceProcessEvents
    | where TimeGenerated >= ago(LookbackWindow)
    | where FileName =~ "wmic.exe"
    | where ProcessCommandLine has_any ("/namespace", "path __EventFilter", "path __EventConsumer", "path __FilterToConsumerBinding")
    | extend
        IsFilterCreation = ProcessCommandLine has "__EventFilter",
        IsConsumerCreation = ProcessCommandLine has "__EventConsumer",
        IsBindingCreation = ProcessCommandLine has "__FilterToConsumerBinding",
        HasSuspiciousPayload = ProcessCommandLine has_any (SuspiciousPayloads),
        WMINamespace = extract(@"/namespace:\\\\[^\\]+\\([^\s]+)", 1, ProcessCommandLine),
        ConsumerPayload = extract(@"ExecutablePath[=\s]+""?([^""]+)""?", 1, ProcessCommandLine)
    | where IsFilterCreation or IsConsumerCreation or IsBindingCreation
    | extend
        DetectionMethod = "WMIC-CLI",
        WMIComponent = case(
            IsFilterCreation, "Filter",
            IsConsumerCreation, "Consumer",
            IsBindingCreation, "Binding",
            "Unknown"
        )
    | project TimeGenerated, DeviceName, DetectionMethod, WMIComponent,
              ProcessCommandLine, ConsumerPayload, WMINamespace,
              InitiatingProcessFileName, AccountName, AccountDomain,
              HasSuspiciousPayload;

// Module 3: WMI COM/API-based Subscription (via suspicious processes)
let COMWMISubscription =
    DeviceEvents
    | where TimeGenerated >= ago(LookbackWindow)
    | where ActionType == "WmiBindEventFilterToConsumer"  // If your EDR provides this
    | extend
        DetectionMethod = "WMI-COM-API",
        WMIComponent = "Binding",  // Binding event indicates complete subscription
        ConsumerPayload = tostring(AdditionalFields.Consumer),
        WMINamespace = tostring(AdditionalFields.Namespace),
        HasSuspiciousPayload = tostring(AdditionalFields.Consumer) has_any (SuspiciousPayloads)
    | project TimeGenerated, DeviceName, DetectionMethod, WMIComponent,
              ProcessCommandLine = "", ConsumerPayload, WMINamespace,
              InitiatingProcessFileName, AccountName, AccountDomain,
              HasSuspiciousPayload;

// Module 4: WMI Repository File Modification (alternative detection.. can comment out if this doesn't work out as intended)
let WMIRepositoryChange =
    DeviceFileEvents
    | where TimeGenerated >= ago(LookbackWindow)
    | where FolderPath has "Windows\\System32\\wbem\\Repository"
    | where FileName in~ ("OBJECTS.DATA", "INDEX.BTR", "MAPPING1.MAP", "MAPPING2.MAP")
    | where ActionType in ("FileCreated", "FileModified")
    | where InitiatingProcessFileName !in (LegitimateWMIProcesses)
    | extend
        DetectionMethod = "WMI-Repository-Modification",
        WMIComponent = "Repository-Change",
        HasSuspiciousPayload = false
    | project TimeGenerated, DeviceName, DetectionMethod, WMIComponent,
              ProcessCommandLine = InitiatingProcessCommandLine, 
              ConsumerPayload = FileName, WMINamespace = "",
              InitiatingProcessFileName, AccountName, AccountDomain,
              HasSuspiciousPayload;

// Combine all detection methods
let AllWMIActivity = union isfuzzy=true 
    PowerShellWMISubscription,
    WMICSubscription,
    COMWMISubscription,
    WMIRepositoryChange;

// Correlation: Detect complete subscription creation (Filter + Consumer + Binding)
AllWMIActivity
| extend CorrelationWindow = bin(TimeGenerated, 5m)
| summarize
    WMIComponents = make_set(WMIComponent),
    DetectionMethods = make_set(DetectionMethod),
    FirstActivity = min(TimeGenerated),
    LastActivity = max(TimeGenerated),
    CommandLines = make_set(ProcessCommandLine),
    Payloads = make_set(ConsumerPayload),
    Namespaces = make_set(WMINamespace),
    InitiatingProcesses = make_set(InitiatingProcessFileName),
    HasAnySuspiciousPayload = max(toint(HasSuspiciousPayload)),
    ActivityCount = count()
by DeviceName, AccountName, AccountDomain, CorrelationWindow
| extend
    HasFilter = WMIComponents has "Filter",
    HasConsumer = WMIComponents has "Consumer",
    HasBinding = WMIComponents has "Binding" or WMIComponents has "Repository-Change",
    TimeDeltaSeconds = datetime_diff('second', LastActivity, FirstActivity),
    IsCompleteSubscription = array_length(WMIComponents) >= 2  // At least 2 components (some methods auto-bind)

// Risk Scoring
| extend
    // Base risk for WMI subscription activity
    BaseRisk = case(
        HasFilter and HasConsumer and HasBinding, 50,  // Complete triad
        HasFilter and HasConsumer, 40,                 // Missing explicit binding (may be implicit)
        HasBinding, 35,                                // Binding detected (implies other components exist)
        20
    ),
    
    // Payload risk
    PayloadRisk = case(
        HasAnySuspiciousPayload == 1, 30,  // Suspicious command detected
        isnotempty(tostring(Payloads[0])), 15,  // Has payload but not overtly suspicious
        5
    ),
    
    // Timing risk (rapid creation = automation/script)
    TimingRisk = case(
        TimeDeltaSeconds <= 10, 15,   // Created in 10 seconds
        TimeDeltaSeconds <= 60, 10,   // Created in 1 minute
        TimeDeltaSeconds <= 300, 5,   // Created in 5 minutes
        0
    ),
    
    // Process risk
    ProcessRisk = case(
        InitiatingProcesses has_any ("cmd.exe", "powershell.exe") and not(InitiatingProcesses has_any (LegitimateWMIProcesses)), 10,
        InitiatingProcesses !has_any (LegitimateWMIProcesses), 5,
        0
    ),
    
    TotalRiskScore = BaseRisk + PayloadRisk + TimingRisk + ProcessRisk

| extend
    AlertSeverity = case(
        TotalRiskScore >= 80, "Critical",
        TotalRiskScore >= 60, "High",
        TotalRiskScore >= 40, "Medium",
        "Low"
    )

// Join with baseline for anomaly detection
| join kind=leftouter (WMIBaseline) on DeviceName
| extend
    IsAnomalous = isnull(BaselineCount) or BaselineCount < 2,
    AdjustedRiskScore = TotalRiskScore + iff(IsAnomalous, 15, 0)

| extend
    Evidence = pack(
        "WMIComponents", WMIComponents,
        "DetectionMethods", DetectionMethods,
        "Payloads", Payloads,
        "Namespaces", Namespaces,
        "InitiatingProcesses", InitiatingProcesses,
        "TimeDelta", TimeDeltaSeconds,
        "ActivityCount", ActivityCount,
        "IsAnomalous", IsAnomalous
    ),
    
    ThreatContext = pack(
        "PersistenceType", "WMI Event Subscription",
        "Components", case(
            IsCompleteSubscription, "Complete Subscription (Filter + Consumer + Binding)",
            HasBinding, "Binding Detected (Complete Subscription Implied)",
            "Partial Subscription"
        ),
        "Sophistication", case(
            TimeDeltaSeconds <= 10, "High (Scripted/Automated)",
            TimeDeltaSeconds <= 60, "Medium (Manual with Preparation)",
            "Low (Manual)"
        )
    ),
    
    Recommendations = case(
        AlertSeverity == "Critical",
        "IMMEDIATE: 1) Isolate device 2) Check for active WMI subscriptions: Get-WmiObject -Namespace root\\subscription -Class __EventFilter/Consumer/Binding 3) Remove malicious subscriptions 4) Analyze payload for C2 indicators 5) Hunt for lateral movement",
        AlertSeverity == "High",
        "URGENT: 1) Validate WMI subscription legitimacy 2) Review payload for malicious intent 3) Check initiating user authorization 4) Enumerate all WMI subscriptions on device",
        "INVESTIGATE: 1) Confirm business justification 2) Review WMI subscription details 3) Validate against approved monitoring/management tools"
    ),
    
    DetectedTechniques = "T1546.003 (Event Triggered Execution: WMI Event Subscription), T1047 (Windows Management Instrumentation)"

// Filter to actionable alerts
| where AlertSeverity in ("Critical", "High", "Medium")

| project
    TimeGenerated = LastActivity,
    DeviceName,
    AccountName,
    AccountDomain,
    AlertSeverity,
    TotalRiskScore = AdjustedRiskScore,
    ActivityWindowSeconds = TimeDeltaSeconds,
    ThreatContext,
    Evidence,
    DetectedTechniques,
    Recommendations

| sort by TotalRiskScore desc, TimeGenerated desc

time_window: 4h
frequency: 15m
trigger: results > 0

fields_returned:
  - LastActivity
  - DeviceName
  - AccountName
  - AccountDomain
  - AlertSeverity
  - AdjustedRiskScore
  - TimeDeltaSeconds
  - ThreatContext
  - Evidence
  - DetectedTechniques
  - Recommendations

references:
  - https://attack.mitre.org/techniques/T1546/003/
  - https://attack.mitre.org/techniques/T1047/ 
  - https://www.sans.org/blog/finding-evil-wmi-event-consumers-with-disk-forensics
  - https://www.elastic.co/docs/reference/security/prebuilt-rules/rules/windows/persistence_via_windows_management_instrumentation_event_subscription
  - https://www.cybertriage.com/blog/how-to-investigate-malware-wmi-event-consumers-2025/

triage: |
  This alert means a hidden, fileless persistence mechanism has been successfully installed on the target device. The goal is to remove the WMI components and clean the payload.
    1.	Immediate Containment & Verification:
      o	Isolate Device: Immediately isolate the DeviceName to prevent the payload from executing (if the trigger hasn't happened yet) or performing further hostile actions.
      o	Verify Legitimacy: Review the InitiatingProcesses and AccountName. Check with the system owner or IT team if the user or process was authorized to install system management tools or run PowerShell with WMI commands at that time. If denied, proceed as a breach.
    2.	WMI Artifact Discovery & Removal (Forensic):
      o	Enumerate Subscriptions: If possible on the isolated device, run the following PowerShell commands to list the three components of the subscription:
        •	Get-CimInstance -Namespace root\subscription -ClassName __EventFilter
        •	Get-CimInstance -Namespace root\subscription -ClassName CommandLineEventConsumer
        • Get-CimInstance -Namespace root\subscription -ClassName __FilterToConsumerBinding
      o	Identify Malicious Artifacts: Cross-reference the discovered Filter/Consumer/Binding names with the Payloads and InitiatingProcesses from the alert evidence.
      o	Remove Subscription: Immediately delete the malicious objects using the appropriate command (e.g., Remove-CimInstance -InputObject $malicious_object). Deletion is the only way to remove the persistence.
    3.	Payload and User Scoping:
      o	Analyze Payload: Review the command line found in the Payloads field. If it contains encoded commands (-enc, IEX), decode them immediately to identify the final command, script, or C2 domain.
      o	Check Initiator: Investigate the activity of the AccountName for the period leading up to the WMI creation. Look for preceding compromise events like credential access or initial access.
      o	Review Execution Logs: Search process creation logs on the device for the execution of the command contained within the WMI ConsumerPayload (e.g., if the payload was powershell.exe -enc ..., look for that process execution).
    4.	Escalation:
      o	Escalate to the Incident Response (IR) team, confirming the discovery and removal of the stealthy T1546.003 persistence mechanism, and provide the identified payload command and initiating account name.

notes: |
  - This detection is one of those that depends on LOLBAS so any FP tuning will need to be very deliberate.

