# DE-HY25.07 Remote Service-Based Lateral Movement Detection
id: DE-HY25.07
title: Remote Service-Based Lateral Movement Detection
description: |
  Detects confirmed lateral movement by correlating remote service creation (e.g., PsExec, NetExec) on a target host with immediate command execution.
severity: High
status: draft
author: \m/
date_created: 2025-10-16
date_modified: 2025-10-16
tags:
  - clarifi_path: Endpoint/Windows/Lateral_Movement
  - tactic: Lateral Movement
  - tactic: Execution
  - technique: Remote Services: SMB/Windows Admin Shares
  - technique: Create or Modify System Process: Windows Service
  - ATT&CK_ID: T1021.002 # Remote Services: SMB/Windows Admin Shares
  - ATT&CK_ID: T1543.003 # Create or Modify System Process: Windows Service
  - method: Correlation/Multi-Event
  - core_indicator: Event_RemoteService
  - core_indicator: Net_RemoteProcessj
  - core_indicator: Event_PrivUsage
  - core_indicator: Cmd_RemoteShell
  - datasource: SecurityEvent
  - datasource: DeviceEvents
  - datasource: DeviceProcessEvents

query: |

// Remote Service-Based Lateral Movement Detection
// Detects PsExec, NetExec, and similar lateral movement tools via service creation + execution correlation

// Parameters
let LookbackWindow = 2h;
let CorrelationWindow = 10s;  // Tight window for service creation → execution
let BaselineWindow = 7d;
let Window = toduration(CorrelationWindow);

// Known legitimate service patterns (I doubt many of these are used in Microsoft, this is just "top stuff". Customize appropriately.)
let LegitimateServices = dynamic([
    // Windows built-in services
    "TrustedInstaller", "wuauserv", "BITS", "EventLog", "Schedule", "WinDefend",
    // Common enterprise software
    "SplunkForwarder", "CrowdStrikeService", "SentinelOne", "CarbonBlack",
    "SCCM", "WSUS", "Tanium", "McAfee", "Symantec",
    // Known admin tools (if approved)
    "RemoteRegistry", "RemoteAccess"
]);

// Suspicious service name patterns (common in lateral movement tools)
let SuspiciousServicePatterns = dynamic([
    "PSEXESVC",      // PsExec default
    "PAExec",        // Alternative PsExec
    "ADMIN$",        // SMB admin share
    "IPC$",          // IPC share
    "RemCom",        // RemCom service
    "BTOBTO",        // NetExec/CrackMapExec
    "WMIC",          // WMIC-based
    "WinRM"          // WinRM remote exec
]);

// Known lateral movement tools and their characteristics
let LateralMovementTools = dynamic([
    "psexec.exe", "psexec64.exe", "paexec.exe",
    "netexec.exe", "crackmapexec.exe", "cme.exe",
    "impacket", "smbexec.py", "atexec.py", "wmiexec.py",
    "remcom.exe", "winexe"
]);

// Module 1: Remote Service Creation Events
let ServiceCreationEvents = 
    SecurityEvent
    | where TimeGenerated >= ago(LookbackWindow)
    | where EventID == 4697  // A service was installed in the system
    | extend
        ServiceName = tostring(extract("Service Name:\\s+([^\\r\\n]+)", 1, EventData)),
        ServiceFileName = tostring(extract("Service File Name:\\s+([^\\r\\n]+)", 1, EventData)),
        ServiceAccount = tostring(extract("Service Account:\\s+([^\\r\\n]+)", 1, EventData)),
        ServiceType = tostring(extract("Service Type:\\s+([^\\r\\n]+)", 1, EventData)),
        // Extract initiator information
        SubjectUserName = tostring(extract("Subject:\\s+Security ID:[^\\r\\n]+\\s+Account Name:\\s+([^\\r\\n]+)", 1, EventData)),
        SubjectDomainName = tostring(extract("Subject:\\s+Security ID:[^\\r\\n]+\\s+Account Name:[^\\r\\n]+\\s+Account Domain:\\s+([^\\r\\n]+)", 1, EventData)),
        SubjectLogonId = tostring(extract("Subject:\\s+Security ID:[^\\r\\n]+\\s+Account Name:[^\\r\\n]+\\s+Account Domain:[^\\r\\n]+\\s+Logon ID:\\s+([^\\r\\n]+)", 1, EventData))
    | where isnotempty(ServiceName)
    // Filter out known legitimate services
    | where ServiceName !in (LegitimateServices)
    // Identify suspicious characteristics
    | extend
        IsSuspiciousName = ServiceName has_any (SuspiciousServicePatterns),
        IsRandomName = strlen(ServiceName) <= 8 and ServiceName matches regex "^[A-Z0-9]{6,8}$",
        IsSystemPath = ServiceFileName startswith "C:\\Windows\\System32" or ServiceFileName startswith "C:\\Windows\\SysWOW64",
        IsTempPath = ServiceFileName has_any ("\\Temp\\", "\\Tmp\\", "\\AppData\\", "\\ProgramData\\"),
        IsAdminShare = ServiceFileName startswith "\\\\",
        HasSuspiciousPath = ServiceFileName has_any ("cmd.exe", "powershell.exe", "wmic.exe", "rundll32.exe")
    | project ServiceCreationTime = TimeGenerated,
              TargetComputer = Computer,
              ServiceName,
              ServiceFileName,
              ServiceAccount,
              SubjectUserName,
              SubjectDomainName,
              SubjectLogonId,
              IsSuspiciousName,
              IsRandomName,
              IsTempPath,
              IsAdminShare,
              HasSuspiciousPath;

// Alternative: EDR-based service creation.. this is a Defender vs Windows Event alternative
let EDRServiceCreation = 
    DeviceEvents
    | where TimeGenerated >= ago(LookbackWindow)
    | where ActionType == "ServiceInstalled"
    | extend
        ServiceName = tostring(AdditionalFields.ServiceName),
        ServiceFileName = tostring(AdditionalFields.ImagePath),
        ServiceAccount = tostring(AdditionalFields.AccountName)
    | where isnotempty(ServiceName)
    | where ServiceName !in (LegitimateServices)
    | extend
        IsSuspiciousName = ServiceName has_any (SuspiciousServicePatterns),
        IsRandomName = strlen(ServiceName) <= 8 and ServiceName matches regex "^[A-Z0-9]{6,8}$",
        IsTempPath = ServiceFileName has_any ("\\Temp\\", "\\Tmp\\", "\\AppData\\", "\\ProgramData\\"),
        IsAdminShare = ServiceFileName startswith "\\\\",
        HasSuspiciousPath = ServiceFileName has_any ("cmd.exe", "powershell.exe", "wmic.exe")
    | project ServiceCreationTime = TimeGenerated,
              TargetComputer = DeviceName,
              ServiceName,
              ServiceFileName,
              ServiceAccount = InitiatingProcessAccountName,
              SubjectUserName = InitiatingProcessAccountName,
              SubjectDomainName = InitiatingProcessAccountDomain,
              SubjectLogonId = InitiatingProcessAccountSid,
              IsSuspiciousName,
              IsRandomName,
              IsTempPath,
              IsAdminShare,
              HasSuspiciousPath;

// Combine both service creation sources
let AllServiceCreation = union isfuzzy=true ServiceCreationEvents, EDRServiceCreation;

// Module 2: Remote Process Execution (spawned by services.exe)
let RemoteProcessExecution =
    DeviceProcessEvents
    | where TimeGenerated >= ago(LookbackWindow)
    // Process spawned by services.exe (service execution)
    | where InitiatingProcessFileName =~ "services.exe"
        or InitiatingProcessCommandLine contains "services.exe"
    // Focus on interactive/command execution processes
    | where FileName in~ ("cmd.exe", "powershell.exe", "pwsh.exe", "wmic.exe", 
                          "rundll32.exe", "regsvr32.exe", "mshta.exe", "cscript.exe", "wscript.exe")
        or ProcessCommandLine has_any ("cmd.exe /c", "powershell.exe -", "cmd /c", "cmd /q")
    | extend
        IsInteractiveShell = FileName in~ ("cmd.exe", "powershell.exe", "pwsh.exe"),
        HasSuspiciousArgs = ProcessCommandLine has_any (
            "-enc", "-EncodedCommand", "-WindowStyle Hidden", "-ExecutionPolicy Bypass",
            "/c ", "whoami", "net user", "net group", "ipconfig", "systeminfo"
        ),
        IsLOLBAS = FileName in~ ("rundll32.exe", "regsvr32.exe", "mshta.exe", "wmic.exe")
    | project ProcessCreationTime = TimeGenerated,
              TargetComputer = DeviceName,
              ProcessFileName = FileName,
              ProcessCommandLine,
              ProcessAccount = AccountName,
              ProcessAccountDomain = AccountDomain,
              ParentProcessName = InitiatingProcessFileName,
              ParentProcessId = InitiatingProcessId,
              IsInteractiveShell,
              HasSuspiciousArgs,
              IsLOLBAS;

// Module 3: Remote Logon Context (for additional correlation)
let RemoteLogons =
    SecurityEvent
    | where TimeGenerated >= ago(LookbackWindow)
    | where EventID in (4624, 4672)  // Logon + Special privileges assigned
    | where LogonType in (3, 10)     // Network logon or RemoteInteractive
    | extend
        LogonUserName = Account,
        LogonDomain = AccountDomain,
        LogonType = LogonType,
        SourceIP = IpAddress,
        LogonId = TargetLogonId
    | project LogonTime = TimeGenerated,
              TargetComputer = Computer,
              LogonUserName,
              LogonDomain,
              SourceIP,
              LogonId,
              LogonType;

// Module 4: Lateral Movement Tool Process Creation (source host context)
let LateralToolExecution =
    DeviceProcessEvents
    | where TimeGenerated >= ago(LookbackWindow)
    | where FileName has_any (LateralMovementTools)
        or ProcessCommandLine has_any (LateralMovementTools)
        or ProcessCommandLine has_any ("psexec", "\\\\", "wmic /node:", "Invoke-Command")
    | extend
        IsPsExec = FileName contains "psexec" or ProcessCommandLine contains "psexec",
        IsNetExec = FileName contains "netexec" or FileName contains "crackmapexec",
        IsWMIC = ProcessCommandLine contains "wmic /node:",
        IsPowerShellRemoting = ProcessCommandLine contains "Invoke-Command" or ProcessCommandLine contains "Enter-PSSession",
        TargetHost = extract(@"\\\\([^\s\\]+)", 1, ProcessCommandLine)
    | where isnotempty(TargetHost) or IsPsExec or IsNetExec or IsWMIC or IsPowerShellRemoting
    | project ToolExecutionTime = TimeGenerated,
              SourceComputer = DeviceName,
              ToolFileName = FileName,
              ToolCommandLine = ProcessCommandLine,
              ToolAccount = AccountName,
              TargetHostFromCommand = TargetHost,
              IsPsExec,
              IsNetExec,
              IsWMIC,
              IsPowerShellRemoting;

// Correlation 1: Service Creation → Process Execution (Core Detection)
let ServiceToProcess = AllServiceCreation
| join kind=inner (RemoteProcessExecution) on TargetComputer
| where ProcessCreationTime between (ServiceCreationTime .. (ServiceCreationTime + Window))
// Additional validation: Service name correlation - this is commented out for now as the time correlation should be strong enough.  Can be added back if needed.
// | where ProcessCommandLine contains ServiceName 
//    or ParentProcessName contains ServiceName
//    or abs(datetime_diff('second', ProcessCreationTime, ServiceCreationTime)) <= 10
| extend
    Signal = "Service_Then_Process",
    TimeDelta = datetime_diff('second', ProcessCreationTime, ServiceCreationTime),
    Evidence = pack(
        "ServiceCreationTime", ServiceCreationTime,
        "ProcessExecutionTime", ProcessCreationTime,
        "ServiceName", ServiceName,
        "ServicePath", ServiceFileName,
        "ExecutedProcess", ProcessCommandLine,
        "TimeDeltaSeconds", TimeDelta
    );

// Correlation 2: Lateral Tool → Service Creation → Process (Full Chain)
let FullLateralChain = LateralToolExecution
| join kind=inner (AllServiceCreation) on $left.TargetHostFromCommand == $right.TargetComputer
| where ServiceCreationTime between (ToolExecutionTime .. (ToolExecutionTime + 30s))
| join kind=inner (RemoteProcessExecution) on $left.TargetComputer == $right.TargetComputer
| where ProcessCreationTime between (ServiceCreationTime .. (ServiceCreationTime + Window))
| extend
    Signal = "Tool_Service_Process_Chain",
    Evidence = pack(
        "SourceHost", SourceComputer,
        "ToolUsed", ToolFileName,
        "TargetHost", TargetComputer,
        "ServiceCreated", ServiceName,
        "ProcessExecuted", ProcessCommandLine,
        "FullChainDuration", datetime_diff('second', ProcessCreationTime, ToolExecutionTime)
    );

// Correlation 3: Remote Logon → Service → Process (Credential-based lateral movement)
let LogonServiceProcess = RemoteLogons
| join kind=inner (AllServiceCreation) on TargetComputer, $left.LogonId == $right.SubjectLogonId
| where ServiceCreationTime between (LogonTime .. (LogonTime + 60s))
| join kind=inner (RemoteProcessExecution) on TargetComputer
| where ProcessCreationTime between (ServiceCreationTime .. (ServiceCreationTime + Window))
| extend
    Signal = "Logon_Service_Process",
    Evidence = pack(
        "RemoteLogonFrom", SourceIP,
        "LogonUser", LogonUserName,
        "ServiceCreated", ServiceName,
        "ProcessExecuted", ProcessCommandLine,
        "LogonType", LogonType
    );

// Combine all correlations
let AllCorrelations = union isfuzzy=true ServiceToProcess, FullLateralChain, LogonServiceProcess
| extend
    User = coalesce(SubjectUserName, ToolAccount, LogonUserName, ProcessAccount),
    Domain = coalesce(SubjectDomainName, LogonDomain, ProcessAccountDomain),
    SourceHost = coalesce(SourceComputer, "Unknown"),
    SignalType = Signal;

// Risk Scoring and Analysis
AllCorrelations
| summarize
    FirstSeen = min(coalesce(ServiceCreationTime, ToolExecutionTime, LogonTime)),
    LastSeen = max(coalesce(ProcessCreationTime, ServiceCreationTime)),
    Signals = make_list(pack(
        "Signal", SignalType,
        "Time", coalesce(ServiceCreationTime, ToolExecutionTime),
        "Evidence", Evidence
    )),
    SignalCount = count(),
    UniqueSignalTypes = dcount(SignalType),
    ServicesCreated = make_set(ServiceName),
    ProcessesExecuted = make_set(ProcessFileName),
    ToolsUsed = make_set(ToolFileName),
    SourceHosts = make_set(SourceHost)
by TargetComputer, User, Domain
| extend
    // Risk scoring
    BaseScore = case(
        UniqueSignalTypes >= 3, 70,  // Full chain detected
        UniqueSignalTypes == 2, 55,  // Partial chain
        UniqueSignalTypes == 1, 40,  // Core correlation only
        20
    ),
    
    ServiceRiskBonus = case(
        ServicesCreated has_any (SuspiciousServicePatterns), 20,  // Known tool patterns
        array_length(ServicesCreated) > 2, 15,                    // Multiple services
        10
    ),
    
    ToolRiskBonus = case(
        ToolsUsed has_any (LateralMovementTools), 15,  // Known lateral tool
        array_length(ToolsUsed) > 0, 10,               // Tool usage detected
        5
    ),
    
    ProcessRiskBonus = case(
        ProcessesExecuted has "powershell", 10,  // PowerShell execution
        ProcessesExecuted has "cmd.exe", 8,      // CMD execution
        5
    ),
    
    TotalRiskScore = BaseScore + ServiceRiskBonus + ToolRiskBonus + ProcessRiskBonus

| extend
    AlertSeverity = case(
        TotalRiskScore >= 85, "Critical",
        TotalRiskScore >= 70, "High",
        TotalRiskScore >= 50, "Medium",
        "Low"
    ),
    
    ActivitySummary = pack(
        "SignalCount", SignalCount,
        "ChainTypes", UniqueSignalTypes,
        "SourceHosts", SourceHosts,
        "ServicesCreated", ServicesCreated,
        "ProcessesExecuted", ProcessesExecuted,
        "ToolsUsed", ToolsUsed,
        "Duration", datetime_diff('minute', LastSeen, FirstSeen)
    ),
    
    Recommendations = case(
        AlertSeverity == "Critical",
        "IMMEDIATE: Isolate target and source hosts, terminate suspicious services, analyze process execution, check for additional lateral movement, revoke compromised credentials",
        AlertSeverity == "High",
        "URGENT: Investigate service creation context, validate tool usage legitimacy, check user authorization for remote administration, review process execution logs",
        AlertSeverity == "Medium",
        "INVESTIGATE: Verify authorized remote administration activity, confirm business justification, review service persistence",
        "MONITOR: Document for baseline understanding"
    ),
    
    DetectedTechniques = "T1021.002 (Remote Services: SMB/Windows Admin Shares), T1543.003 (Create or Modify System Process: Windows Service), T1570 (Lateral Tool Transfer), T1047 (Windows Management Instrumentation)"

| where AlertSeverity in ("Critical", "High", "Medium")
| project
    TimeGenerated = LastSeen,
    TargetComputer,
    SourceComputers = SourceHosts,
    UserPrincipalName = strcat(Domain, "\\", User),
    AlertSeverity,
    TotalRiskScore,
    ActivityWindowMinutes = datetime_diff('minute', LastSeen, FirstSeen),
    SignalCount,
    LateralMovementChain = UniqueSignalTypes,
    ServicesCreated,
    ProcessesExecuted,
    ToolsUsed,
    Signals,
    ActivitySummary,
    DetectedTechniques,
    Recommendations
| sort by TotalRiskScore desc, TimeGenerated desc

time_window: 4h
frequency: 15m
trigger: results > 0

fields_returned:
  - LastSeen
  - TargetComputer
  - SourceHosts
  - UserPrincipalName
  - AlertSeverity
  - TotalRiskScore
  - ActivityWindowMinutes
  - SignalCount
  - LateralMovementChain
  - ServicesCreated
  - ProcessesExecuted
  - ToolsUsed
  - Signals
  - ActivitySummary
  - DetectedTechniques
  - Recommendations

references:
  - https://attack.mitre.org/techniques/T1560/ (Archive Collected Data)
  - https://attack.mitre.org/techniques/T1567/ (Exfiltration to Cloud Storage)
  - https://learn.microsoft.com/azure/active-directory/ (tuning & investigation guidance)

triage: |
  1.	For Critical Alerting, Immediate Containment & Verification (Target and Source Hosts)
    o	Isolate Target Host: Immediately isolate the TargetComputer to prevent further execution.
    o	Isolate Source Host: Immediately isolate the SourceComputer (if identified in the SourceHosts field) as this is likely the attacker's initial foothold or pivot point.
    o	Verify Legitimacy: Consult with the reported user (UserPrincipalName) and their manager to confirm if any legitimate remote administrative task was executed against the TargetComputer at the TimeGenerated. If denied, proceed as a breach.
  2.	Credential Scoping
    o	Review Account: Examine the account used (UserPrincipalName). Force a password reset and revoke all active sessions and refresh tokens immediately, as the credentials used for the service creation/remote login are compromised.
    o	Check Admin Status: Determine if the account is a privileged administrator. If so, immediately check all privileged access logs for the past 24 hours.
  3.	Artifact Analysis (On Target Host)
    o	Check Services: Search the target host for any running services that match the suspicious service name patterns (PSEXESVC, random 6-8 character names) or the names listed in the ServicesCreated field. Terminate and delete them.
    o	Analyze Command Line: Review the full command line (ProcessCommandLine within the Signals field) for the remote process execution. Look for known malicious payloads, base64-encoded strings, or enumeration commands (whoami, net group, ipconfig).
    o	Check Tool Usage: If the ToolsUsed field shows a known lateral tool (psexec, netexec), review all associated logs on the Source Host for the tool's execution history.
  4.	Scope and Escalation
    o	Check Neighbors: Search the logs for any lateral movement attempts originating from the Target Host after the initial compromise, or any additional service creation events targeting other hosts.
    o	Escalate: Immediately escalate, providing the Target Host, Source Host, Compromised Account, and the Services/Processes Executed as the initial data set.


notes: |

