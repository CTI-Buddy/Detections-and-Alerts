id: PS-001
title: Password Spray with Conditional Access Block
description: Detects successful credential guesses during a password spray where access was denied by Conditional Access policies. Indicates valid credentials have been obtained, even though sign-in was blocked.
severity: High
status: production
author: Detection Engineering Team
date_created: 2025-09-02
date_modified: 2025-09-02
tags:
  - tactic: Credential Access
  - technique: T1110.003
  - datasource: SigninLogs
  - platform: AzureAD
logic:
  query: |
    let SprayIPs = SigninLogs
    | where TimeGenerated > ago(1h)
    | where ResultType != 0
    | summarize FailedUsers = dcount(UserPrincipalName), Attempts = count() by IPAddress
    | where FailedUsers > 5 and Attempts > 20;
    
    SigninLogs
    | where TimeGenerated > ago(1h)
    | where ResultType == 0
    | where ConditionalAccessStatus == "failure"
    | join kind=inner (SprayIPs) on IPAddress
    | project TimeGenerated, UserPrincipalName, IPAddress, AppDisplayName, Status, ConditionalAccessStatus, FailedUsers, Attempts
  time_window: 1h
  frequency: 5m
  trigger: results > 0
entities:
  - UserAccount
  - IPAddress
fields_returned:
  - TimeGenerated
  - UserPrincipalName
  - IPAddress
  - AppDisplayName
  - ConditionalAccessStatus
references:
  - https://attack.mitre.org/techniques/T1110/003/
  - https://learn.microsoft.com/en-us/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
triage:
  - Confirm IP reputation (TOR, VPN, hosting providers).
  - Check whether targeted accounts are privileged.
  - Reset passwords or enforce MFA on impacted accounts.
  - Hunt for other activity from the same IP across services.
notes: |
  This rule may fire when red teams or penetration testers run spray campaigns. Tune thresholds (FailedUsers, Attempts) to reduce false positives.



/////


(DLL sideload)
DeviceImageLoadEvents
| where Timestamp > ago(1h)
| where InitiatingProcessFileName in~ ("OneDrive.exe", "Teams.exe", "svchost.exe", "rundll32.exe")
// Filter to binaries commonly abused for sideloading
| where not(FolderPath startswith "C:\\Program Files" or FolderPath startswith "C:\\Windows")
// DLL loading from unexpected directory
| project Timestamp, DeviceName, InitiatingProcessFileName, InitiatingProcessFolderPath, FileName, FolderPath, SHA256, InitiatingProcessAccountName


//////


(PHP Webshell)
DeviceFileEvents
| where ActionType == "FileCreated"
| where FileName matches regex @"(?i)\.(php|phtml|asp|aspx|jsp|jspx)$"
| where FolderPath has_any ("inetpub\\wwwroot", "htdocs", "/var/www/html")
| where InitiatingProcessFileName in~ ("w3wp.exe", "httpd.exe", "nginx.exe", "php-cgi.exe", "tomcat.exe", "java.exe")
| where not(FolderPath has_any ("phpmyadmin", "upgrade", "install"))
| extend WebshellIndicator = 1





title: Webshell File Creation in Web Root
id: f7a3c1d6-0b2b-4a72-8d85-09a93e5cba12
status: experimental
description: Detects creation of common webshell file types (.php, .phtml, .aspx, .jsp) in typical web server directories by web server processes.
author: \m/
date: 2025-09-02
tags:
  - attack.persistence
  - attack.t1505.003 # Web Shell
logsource:
  product: windows
  category: file_event
detection:
  selection:
    ActionType: FileCreated
    FileName|endswith:
      - ".php"
      - ".phtml"
      - ".aspx"
      - ".jsp"
    FolderPath|contains_any:
      - "inetpub\\wwwroot"
      - "htdocs"
      - "/var/www/html"
    InitiatingProcessFileName|in:
      - "w3wp.exe"
      - "httpd.exe"
      - "nginx.exe"
      - "php-cgi.exe"
  filter:
    FolderPath|contains_any:
      - "phpmyadmin"
      - "upgrade"
      - "install"
  condition: selection and not filter
logic:
  query: |
DeviceFileEvents
| where ActionType == "FileCreated"
| where FileName matches regex @"(?i)\.(php|phtml|asp|aspx|jsp|jspx)$"
| where FolderPath has_any ("inetpub\\wwwroot", "htdocs", "/var/www/html")
| where InitiatingProcessFileName in~ ("w3wp.exe", "httpd.exe", "nginx.exe", "php-cgi.exe", "tomcat.exe", "java.exe")
| where not(FolderPath has_any ("phpmyadmin", "upgrade", "install"))
| extend WebshellIndicator = 1
fields:
  - DeviceId
  - FileName
  - FolderPath
  - InitiatingProcessFileName
  - InitiatingProcessCommandLine
level: high



///


id: <unique-detection-id>
title: <detection name>
description: <short summary of what the detection finds>
severity: <High | Medium | Low>
status: <experimental | production | deprecated>
author: <your name/team>
date_created: <YYYY-MM-DD>
date_modified: <YYYY-MM-DD>
tags:
  - tactic: <MITRE ATT&CK tactic>
  - technique: <ATT&CK technique ID>
  - datasource: <table(s) used>
  - platform: <Windows | AzureAD | M365 | Linux>
logic:
  query: |
    <KQL query here>
  time_window: <e.g. 1h>
  frequency: <how often query should run>
  trigger: <e.g. number of results > 0>
entities:
  - UserAccount
  - IPAddress
  - Device
fields_returned:
  - Timestamp
  - UserPrincipalName
  - IPAddress
  - AppDisplayName
references:
  - <URL to ATT&CK>
  - <research/blog/advisory>
triage:
  - <what the SOC should check>
  - <follow-up steps>
notes: |
  <any caveats, tuning guidance, or known FPs>



///////


let timeframe = 14d;
SigninLogs
| where TimeGenerated > ago(timeframe)
| where ResultType == "0"  // Successful sign-ins only
| extend CompositeState = pack(
    "UA", UserAgent,
    "DeviceId", tostring(DeviceDetail.deviceId),
    "AuthReq", AuthenticationRequirement,
    "CAStatus", ConditionalAccessStatus,
    "IP", IPAddress,
    "Location", Location,
    "Risk", RiskLevelDuringSignIn
  )
| partition hint.strategy=native by UserPrincipalName (
    order by TimeGenerated asc
    | scan declare (expected_states: dynamic = dynamic([])) with (
        step s: true =>
        expected_states = set_union(s.expected_states, pack_array(CompositeState))
    )
    | extend PreviousStates = expected_states[0:-1]
    | extend CurrentState = tostring(CompositeState)
    | extend RiskScore =
        iif(UserAgent !in (PreviousStates.UA), 5, 0) +
        iif(tostring(DeviceDetail.deviceId) !in (PreviousStates.DeviceId), 10, 0) +
        iif(AuthenticationRequirement != PreviousStates.AuthReq, 10, 0) +
        iif(ConditionalAccessStatus != PreviousStates.CAStatus, 5, 0) +
        iif(RiskLevelDuringSignIn != "none", 10, 0) +
        iif(Location != PreviousStates.Location, 1, 0)
    | where RiskScore > 0
)
| project TimeGenerated, UserPrincipalName, CurrentState, RiskScore
| order by RiskScore desc


////

title: Azure AD Sign-in State Change with Risk Scoring
id: 7c1ef1c9-82ab-45e8-9c1b-5f3c2b24a871
status: experimental
description: |
  Detects suspicious state changes in Azure AD sign-ins, such as new devices,
  changes in authentication requirements, or Conditional Access enforcement shifts.
  Each state change is assigned a weighted risk score. High scores indicate higher
  likelihood of account compromise.
author: Your Name
date: 2025-09-02
tags:
  - attack.credential_access
  - attack.t1078 # Valid Accounts
  - azure
  - o365
logsource:
  product: azure
  service: signinlogs
detection:
  query: |
    let timeframe = 14d;
    SigninLogs
    | where TimeGenerated > ago(timeframe)
    | where ResultType == "0"  // Successful sign-ins only
    | extend CompositeState = pack(
        "UA", UserAgent,
        "DeviceId", tostring(DeviceDetail.deviceId),
        "AuthReq", AuthenticationRequirement,
        "CAStatus", ConditionalAccessStatus,
        "IP", IPAddress,
        "Location", Location,
        "Risk", RiskLevelDuringSignIn
      )
    | partition hint.strategy=native by UserPrincipalName (
        order by TimeGenerated asc
        | scan declare (expected_states: dynamic = dynamic([])) with (
            step s: true =>
            expected_states = set_union(s.expected_states, pack_array(CompositeState))
        )
        | extend PreviousStates = expected_states[0:-1]
        | extend CurrentState = tostring(CompositeState)
        | extend RiskScore =
            iif(UserAgent !in (PreviousStates.UA), 5, 0) +
            iif(tostring(DeviceDetail.deviceId) !in (PreviousStates.DeviceId), 10, 0) +
            iif(AuthenticationRequirement != PreviousStates.AuthReq, 10, 0) +
            iif(ConditionalAccessStatus != PreviousStates.CAStatus, 5, 0) +
            iif(RiskLevelDuringSignIn != "none", 10, 0) +
            iif(Location != PreviousStates.Location, 1, 0)
        | where RiskScore > 0
    )
    | project TimeGenerated, UserPrincipalName, CurrentState, RiskScore
    | order by RiskScore desc
level: medium
fields:
  - TimeGenerated
  - UserPrincipalName
  - CurrentState
  - RiskScore
falsepositives:
  - Legitimate user traveling internationally or switching VPN providers.
  - User upgrading/replacing a device.
  - New MFA policies being rolled out.
mitre:
  technique: T1078
  tactic: credential-access


