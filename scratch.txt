# DE-HY25.15 Service Account Logon Anomaly Detection 
id: DE-HY25.15
title: Azure Security Center/Defender Modification Detection
description: |
  Detects a service account logging onto a device (especially a DC or workstation) it has 
  no history of accessing, highly correlated with lateral movement attacks.
severity: High
status: draft
author: \m/
date_created: 2025-10-22
date_modified: 2025-10-22
tags:
  - clarifi_path: Endpoint/Windows/Lateral_Movement
  - tactic: Lateral Movement
  - tactic: Credential Access
  - technique: Valid Accounts: Domain Accounts 
  - technique: Remote Services
  - technique: Lateral Tool Transfer
  - ATT&CK_ID: T1078.002 # Valid Accounts: Domain Accounts
  - ATT&CK_ID: T1021 # Remote Services
  - ATT&CK_ID: T1570 # Lateral Tool Transfer   
  - method: Correlation/Sequence
  - method: Statistical/Baseline-Comparison
  - method: Behavioral/Model-Classification
  - core_indicator: Event_AccountAnomaly
  - core_indicator: Vol_LoginSpike
  - core_indicator: Access_DomainController 
  - datasource: DeviceInfo
  - datasource: DeviceLogonEvents
  - datasource: IdentityInfo

logic:
  query: |

// LSASS Credential Dumping Detection
// Detects unauthorized memory access to LSASS.exe for credential harvesting

// Parameters
let DetectionWindow = 7d;
let BaselineWindow = 30d;
let TargetProcess = "lsass.exe";

// Known credential dumping tools
let CredentialDumpingTools = dynamic([
    "mimikatz.exe", "mimilib.dll", "mimidrv.sys",
    "procdump.exe", "procdump64.exe",
    "dumpert.exe", "nanodump.exe",
    "sqldumper.exe", "createdump.exe",
    "out-minidump", "invoke-mimikatz",
    "sharpdump.exe", "pypykatz",
    "lsassy", "secretsdump"
]);

// Legitimate processes that may access LSASS (customize for your environment)
let LegitimateAccessors = dynamic([
    // Windows System Processes
    "csrss.exe", "wininit.exe", "services.exe", "svchost.exe",
    "lsm.exe", "smss.exe", "winlogon.exe", "logonui.exe",
    // Security Software
    "msmpeng.exe", "mpcmdrun.exe", "msseces.exe", "nissrv.exe",  // Windows Defender
    "avp.exe", "kavtray.exe",                                     // Kaspersky
    "mcshield.exe", "mfevtps.exe",                               // McAfee
    "savservice.exe", "sophoshealth.exe",                        // Sophos
    "ccsvchst.exe", "ccsvchst.exe",                              // Symantec
    // EDR/Security Tools
    "taniumclient.exe", "cb.exe", "sentinelone.exe",
    "crowdstrike.exe", "falconsensor.exe",
    // System Management
    "wmiprvse.exe", "taskmgr.exe",
    // Monitoring/Diagnostic (if approved)
    "procexp.exe", "procexp64.exe", "procmon.exe", "procmon64.exe"  // Sysinternals (if authorized)
]);

// Suspicious execution paths
let SuspiciousPaths = dynamic([
    "\\temp\\", "\\tmp\\", 
    "\\appdata\\local\\temp\\", "\\appdata\\roaming\\",
    "\\programdata\\", "\\public\\", "\\users\\public\\",
    "\\downloads\\", "\\desktop\\",
    "\\perflogs\\", "\\recycler\\", "\\recycle.bin\\",
    "\\inetpub\\", "\\wwwroot\\"
]);

// High-privilege access rights for memory reading
// Reference: https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights
let DangerousAccessRights = dynamic([
    "0x1410",     // PROCESS_QUERY_INFORMATION | PROCESS_VM_READ
    "0x1fffff",   // PROCESS_ALL_ACCESS
    "0x1000",     // PROCESS_QUERY_LIMITED_INFORMATION  
    "0x0010",     // PROCESS_VM_READ
    "0x0400",     // PROCESS_QUERY_INFORMATION
    "0x0800"      // PROCESS_SUSPEND_RESUME
]);

// Get baseline of LSASS access patterns
let LsassAccessBaseline =
    DeviceEvents
    | where TimeGenerated between (ago(BaselineWindow) .. ago(DetectionWindow))
    | where ActionType == "OpenProcessApiCall"
    | where FileName =~ TargetProcess or ProcessCommandLine has TargetProcess
    | summarize 
        BaselineAccessCount = count(),
        BaselineAccessors = make_set(InitiatingProcessFileName)
    by DeviceName;

// Module 1: Direct Process Access Events (Primary Detection)
let DirectLsassAccess = DeviceEvents
| where TimeGenerated >= ago(DetectionWindow)
| where ActionType in ("OpenProcessApiCall", "ProcessAccess", "SetThreadContextRemoteApiCall")
// Target process is LSASS
| where FileName =~ TargetProcess 
    or ProcessCommandLine has TargetProcess
    or AdditionalFields has TargetProcess
| extend
    AccessingProcess = InitiatingProcessFileName,
    AccessingProcessPath = tolower(InitiatingProcessFolderPath),
    AccessingCommandLine = InitiatingProcessCommandLine,
    AccessingParentProcess = InitiatingProcessParentFileName,
    AccessMask = tostring(AdditionalFields.DesiredAccess),
    TargetProcessId = ProcessId,
    AccessingAccount = InitiatingProcessAccountName,
    AccessingDomain = InitiatingProcessAccountDomain
| extend
    // Detection flags
    IsKnownDumpingTool = AccessingProcess has_any (CredentialDumpingTools) 
        or AccessingCommandLine has_any (CredentialDumpingTools),
    IsLegitimateAccessor = AccessingProcess in~ (LegitimateAccessors),
    IsFromSuspiciousPath = AccessingProcessPath has_any (SuspiciousPaths),
    HasDangerousAccessRights = AccessMask has_any (DangerousAccessRights) or AccessMask == "",  // Empty often means full access
    IsUnsignedBinary = isempty(InitiatingProcessVersionInfoOriginalFileName) or InitiatingProcessVersionInfoOriginalFileName == "",
    IsScriptingEngine = AccessingProcess in~ ("powershell.exe", "pwsh.exe", "cmd.exe", "wscript.exe", "cscript.exe"),
    IsOffHours = hourofday(TimeGenerated) not between (7 .. 19)  // Outside business hours
| where not(IsLegitimateAccessor)  // Filter known good
| extend DetectionMethod = "Direct-Process-Access";

// Module 2: LSASS Memory Dump File Creation
let LsassDumpFiles = DeviceFileEvents
| where TimeGenerated >= ago(DetectionWindow)
| where ActionType in ("FileCreated", "FileRenamed")
| where FileName endswith ".dmp" 
    or FileName has "lsass"
    or FileName matches regex @"(?i)lsass.*\.dmp$"
    or FileName matches regex @"(?i).*dump.*\.dmp$"
| extend
    AccessingProcess = InitiatingProcessFileName,
    AccessingProcessPath = tolower(InitiatingProcessFolderPath),
    AccessingCommandLine = InitiatingProcessCommandLine,
    AccessingParentProcess = InitiatingProcessParentFileName,
    DumpFilePath = FolderPath,
    AccessingAccount = InitiatingProcessAccountName,
    AccessingDomain = InitiatingProcessAccountDomain
| extend
    IsKnownDumpingTool = AccessingProcess has_any (CredentialDumpingTools),
    IsLegitimateAccessor = AccessingProcess in~ (LegitimateAccessors),
    IsFromSuspiciousPath = AccessingProcessPath has_any (SuspiciousPaths) or DumpFilePath has_any (SuspiciousPaths),
    HasDangerousAccessRights = true,  // Creating dump file implies access
    IsUnsignedBinary = isempty(InitiatingProcessVersionInfoOriginalFileName),
    IsScriptingEngine = AccessingProcess in~ ("powershell.exe", "pwsh.exe", "cmd.exe"),
    IsOffHours = hourofday(TimeGenerated) not between (7 .. 19)
| where not(IsLegitimateAccessor)
| extend DetectionMethod = "LSASS-Dump-File-Creation";

// Module 3: Task Manager / Debugging Tools (Context-Aware)
let TaskManagerDump = DeviceProcessEvents
| where TimeGenerated >= ago(DetectionWindow)
| where FileName =~ "taskmgr.exe" and ProcessCommandLine has "lsass"
    or (FileName in~ ("procdump.exe", "procdump64.exe") and ProcessCommandLine has "lsass")
    or (FileName =~ "rundll32.exe" and ProcessCommandLine has_any ("MiniDumpW", "comsvcs.dll"))
| extend
    AccessingProcess = FileName,
    AccessingProcessPath = tolower(FolderPath),
    AccessingCommandLine = ProcessCommandLine,
    AccessingParentProcess = InitiatingProcessParentFileName,
    AccessingAccount = AccountName,
    AccessingDomain = AccountDomain
| extend
    IsKnownDumpingTool = AccessingProcess has_any (CredentialDumpingTools) 
        or AccessingCommandLine has "comsvcs.dll",  // Classic DLL injection technique
    IsLegitimateAccessor = false,  // These need validation
    IsFromSuspiciousPath = AccessingProcessPath has_any (SuspiciousPaths),
    HasDangerousAccessRights = true,
    IsUnsignedBinary = false,
    IsScriptingEngine = false,
    IsOffHours = hourofday(TimeGenerated) not between (7 .. 19)
| extend DetectionMethod = "Dumping-Tool-Execution";

// Combine all detection methods
let AllLsassAccess = union isfuzzy=true DirectLsassAccess, LsassDumpFiles, TaskManagerDump;

// Risk Scoring and Analysis
AllLsassAccess
| extend
    // Base risk by detection method
    MethodRisk = case(
        DetectionMethod == "LSASS-Dump-File-Creation", 40,  // Creating dump is direct evidence
        DetectionMethod == "Dumping-Tool-Execution", 35,    // Known tool usage
        DetectionMethod == "Direct-Process-Access", 30,     // Process access attempt
        20
    ),
    
    // Tool/process risk
    ToolRisk = case(
        IsKnownDumpingTool, 35,                   // Known credential dumping tool
        AccessingProcess in~ ("procdump.exe", "procdump64.exe", "taskmgr.exe"), 25,  // Dumping capability
        AccessingProcess =~ "rundll32.exe", 20,   // Common LOLBAS
        IsScriptingEngine, 15,                    // Scripting wrapper
        10
    ),
    
    // Context risk
    ContextRisk = case(
        IsFromSuspiciousPath and IsUnsignedBinary, 25,  // Suspicious path + unsigned
        IsFromSuspiciousPath, 20,                       // Suspicious execution location
        IsUnsignedBinary, 15,                           // Unsigned binary
        IsOffHours, 10,                                 // Off-hours access
        5
    ),
    
    // Access rights risk
    AccessRisk = case(
        HasDangerousAccessRights, 10,  // Has memory read capability
        5
    ),
    
    TotalRiskScore = MethodRisk + ToolRisk + ContextRisk + AccessRisk

| extend
    AlertSeverity = case(
        TotalRiskScore >= 85, "Critical",
        TotalRiskScore >= 70, "High",
        TotalRiskScore >= 50, "Medium",
        "Low"
    )

// Join with baseline for anomaly detection
| join kind=leftouter (LsassAccessBaseline) on DeviceName
| extend
    IsAnomalousAccessor = not(BaselineAccessors has AccessingProcess),
    AdjustedRiskScore = TotalRiskScore + iff(IsAnomalousAccessor, 15, 0)

| extend
    Evidence = pack(
        "DetectionMethod", DetectionMethod,
        "AccessingProcess", AccessingProcess,
        "AccessingProcessPath", AccessingProcessPath,
        "AccessingCommandLine", AccessingCommandLine,
        "ParentProcess", AccessingParentProcess,
        "AccessMask", AccessMask,
        "TargetProcessId", TargetProcessId,
        "IsKnownDumpingTool", IsKnownDumpingTool,
        "IsFromSuspiciousPath", IsFromSuspiciousPath,
        "IsUnsignedBinary", IsUnsignedBinary,
        "IsAnomalousAccessor", IsAnomalousAccessor
    ),
    
    ThreatContext = pack(
        "AttackType", case(
            IsKnownDumpingTool, "Known Credential Dumping Tool",
            DetectionMethod == "LSASS-Dump-File-Creation", "LSASS Memory Dump Creation",
            DetectionMethod == "Dumping-Tool-Execution", "Dumping Tool Execution",
            "Suspicious LSASS Access"
        ),
        "CommonTools", case(
            AccessingProcess has "mimikatz", "Mimikatz",
            AccessingProcess has "procdump", "ProcDump",
            AccessingCommandLine has "comsvcs.dll", "DLL Injection (comsvcs)",
            AccessingProcess =~ "taskmgr.exe", "Task Manager",
            "Unknown/Custom Tool"
        )
    ),
    
    Recommendations = case(
        AlertSeverity == "Critical",
        "IMMEDIATE P0: 1) Isolate device from network 2) Terminate accessing process and all child processes 3) Force password reset for ALL users who logged on to this device 4) Capture memory dump for forensics 5) Hunt for lateral movement 6) Engage incident response team",
        AlertSeverity == "High",
        "URGENT: 1) Validate process legitimacy with user/system owner 2) If unauthorized, isolate device 3) Review recent logons to identify compromised accounts 4) Check for credential reuse across environment 5) Terminate suspicious process",
        "INVESTIGATE: 1) Confirm authorized diagnostic/debugging activity 2) Validate user authorization for LSASS access 3) Review process execution context and justification"
    ),
    
    DetectedTechniques = "T1003.001 (OS Credential Dumping: LSASS Memory), T1055 (Process Injection), T1106 (Native API)"

// Filter to actionable alerts
| where AlertSeverity in ("Critical", "High", "Medium")

| project
    TimeGenerated,
    DeviceName,
    AlertSeverity,
    TotalRiskScore = AdjustedRiskScore,
    AccessingAccount = strcat(AccessingDomain, "\\", AccessingAccount),
    AccessingProcess,
    AccessingProcessPath,
    ThreatContext,
    Evidence,
    DetectedTechniques,
    Recommendations

| sort by TotalRiskScore desc, TimeGenerated desc

references:
  - https://attack.mitre.org/techniques/T1078/002/
  - https://attack.mitre.org/techniques/T1021/
  - https://attack.mitre.org/techniques/T1570/
  - https://web-assets.esetstatic.com/wls/2019/10/ESET_Operation_Ghost_Dukes.pdf
  - https://cloud.google.com/blog/topics/threat-intelligence/suspected-apt-actors-leverage-bypass-techniques-pulse-secure-zero-day/
  - https://web.archive.org/web/20230218064220/https://research.nccgroup.com/2021/01/12/abusing-cloud-services-to-fly-under-the-radar/
  - https://thehackernews.com/2024/09/wherever-theres-ransomware-theres.html

triage: |
  This alert means a service account is logging onto a host it has never accessed before, potentially using compromised credentials (Pass-the-Hash/Ticket, or credential harvesting).
    1. IMMEDIATE Containment & Account Disruption
      •	Identify Compromised Account: Record the ServiceAccount.
      •	Isolate Target/Source: Immediately isolate the TargetDevice and any devices listed in TargetDevices (if a Lateral Movement Pattern) and, if the source is known, isolate the source device to stop the spread.
      •	Invalidate Credential (CRITICAL):
        o	If possible, force a password change (long, complex) for the ServiceAccount.
        o	If a gMSA/MSA, investigate the recent key retrieval and update its permissions, or temporarily suspend its usage.
        o	Revoke all Kerberos tickets and force a logoff for the account across all domain controllers.
    2. Forensic Scoping on Target Devices
      •	DC Access: If the alert involved a Domain Controller target, prioritize a full forensic memory and disk analysis of that DC immediately, as the attacker likely retrieved the NTDS.dit or golden ticket material.
      •	Target Activity: On the TargetDevice (and all devices in TargetDevices):
        o	Review all logons immediately following the anomalous logon for processes spawned by the service account.
        o	Look for execution of credential dumping tools (e.g., Mimikatz, Procdump).
        o	Look for signs of data staging or tool transfer (net use, Admin shares access).
    3. Credential Compromise Root Cause
      •	Source Device Investigation: If a SourceDevice is identified (or if the logon originated from a Workstation), investigate that machine for the root cause:
        o	Was it infected with a keylogger or malware?
        o	Was a local credential dump performed on that device?
        o	If the service account logs onto the source device legitimately, that device is the probable point of initial credential compromise.
      •	Failed Logons/Velocity Check: Use the FailedAttempts and IsSprayPattern flags to confirm the attack type. High failed counts suggest brute force or spraying; a high RapidLogonCount suggests an automated script (like a worm or a built-in attack tool).
    4. Escalation
      •	Escalate: Confirm the incident as a breach involving Lateral Movement and Credential Access. Escalations team should coordinate a domain-wide check for other compromised accounts and ensure the service account is no longer usable by the attacker.

notes: |
  - I attempted an off hours piece of this but frankly that's probably not going to work for this environment.  Be progressive about cutting it off early if it can'be be salvaged.
