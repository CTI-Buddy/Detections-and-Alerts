# DE-HY25.15 Service Account Logon Anomaly Detection 
id: DE-HY25.15
title: Azure Security Center/Defender Modification Detection
description: |
  Detects a service account logging onto a device (especially a DC or workstation) it has 
  no history of accessing, highly correlated with lateral movement attacks.
severity: High
status: draft
author: \m/
date_created: 2025-10-22
date_modified: 2025-10-22
tags:
  - clarifi_path: Endpoint/Windows/Lateral_Movement
  - tactic: Lateral Movement
  - tactic: Credential Access
  - technique: Valid Accounts: Domain Accounts 
  - technique: Remote Services
  - technique: Lateral Tool Transfer
  - ATT&CK_ID: T1078.002 # Valid Accounts: Domain Accounts
  - ATT&CK_ID: T1021 # Remote Services
  - ATT&CK_ID: T1570 # Lateral Tool Transfer   
  - method: Correlation/Sequence
  - method: Statistical/Baseline-Comparison
  - method: Behavioral/Model-Classification
  - core_indicator: Event_AccountAnomaly
  - core_indicator: Vol_LoginSpike
  - core_indicator: Access_DomainController 
  - datasource: DeviceInfo
  - datasource: DeviceLogonEvents
  - datasource: IdentityInfo

logic:
  query: |

// Lateral Movement: Service Account Logon Anomaly Detection 
// Detects service accounts authenticating to unusual devices, indicating potential lateral movement

// Configuration
let BaselinePeriod = 30d;    // Extended baseline 
let DetectionWindow = 7d;     // Active detection period
let MinBaselineLogons = 3;    // Minimum logons to establish valid baseline
let VelocityWindow = 5m;      // Window for detecting rapid logon attempts
let OffHoursStart = 1;       // 9am THESE PROBABLY WILL NOT WORK TBH - Right now just tuned to RU/CN day shift and that's kind of dumb
let OffHoursEnd = 9;          // 5pm Beijing/Guangdong time

// Service account identification patterns (THESE MUST BE VERY PRECISE AND REAL)
let ServiceAccountPrefixes = dynamic([
    "svc", "svc_", "svc-", "service", "srv", "srv_",
    "app", "appsvc", "automation", "sql", "iis", "mon"
]);

let ServiceAccountSuffixes = dynamic([
    "$",           // Managed Service Accounts (MSA/gMSA)
    "service",
    "svc",
    "sql",
    "admin",       // Often service admin accounts
    "system"
]);

// Built-in Windows service accounts
let BuiltInServiceAccounts = dynamic([
    "SYSTEM", "LOCAL SERVICE", "NETWORK SERVICE",
    "NT AUTHORITY\\SYSTEM", "NT AUTHORITY\\LOCAL SERVICE",
    "NT AUTHORITY\\NETWORK SERVICE"
]);

// Privileged groups (high-value targets for attackers)
let PrivilegedGroups = dynamic([
    "Domain Admins", "Enterprise Admins", "Schema Admins",
    "Administrators", "Account Operators", "Backup Operators",
    "Server Operators", "Print Operators"
]);

// Known admin workstations/jump boxes (AGAIN - VERY IMPORTANT TO BE PRECISE)
let AdminWorkstations = dynamic([
    // "ADMIN-WS-01", "JUMP-BOX-01", "PAW-"
]);

// --- Get Current Device Information ---
let CurrentDevices = DeviceInfo
| where TimeGenerated >= ago(1d)
| summarize arg_max(TimeGenerated, *) by DeviceId
| extend
    IsWorkstation = OSPlatform contains "Windows" and (DeviceType =~ "Workstation" or DeviceType =~ "Laptop"),
    IsServer = OSPlatform contains "Server" or DeviceType =~ "Server",
    IsDomainController = DeviceName has "DC" or DeviceName has "DC-" or DeviceName startswith "DC",
    IsVDI = DeviceName has "VDI" or DeviceName has "VIRTUAL",
    DeviceCategory = case(
        OSPlatform contains "Server" or DeviceType =~ "Server", "Server",
        DeviceType =~ "Workstation" or DeviceType =~ "Laptop", "Workstation",
        "Other"
    )
| project DeviceId, DeviceName, OSPlatform, DeviceType, DeviceCategory,
          IsWorkstation, IsServer, IsDomainController, IsVDI;

// --- Module 1: Build Service Account Baseline ---
let ServiceAccountBaseline = DeviceLogonEvents
| where TimeGenerated between (ago(BaselinePeriod) .. ago(DetectionWindow))
| where ActionType == "LogonSuccess"
| extend AccountLower = tolower(AccountName)
// Identify service accounts
| where AccountLower has_any (ServiceAccountPrefixes)
    or AccountLower has_any (ServiceAccountSuffixes)
    or AccountName in~ (BuiltInServiceAccounts)
    or AccountName endswith "$"
| join kind=inner (CurrentDevices) on DeviceId
| summarize
    BaselineDevices = make_set(DeviceName),
    BaselineDeviceIds = make_set(DeviceId),
    BaselineLogonCount = count(),
    BaselineDeviceTypes = make_set(DeviceCategory),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated),
    CommonLogonTypes = make_set(LogonType),
    CommonHours = make_set(hourofday(TimeGenerated))
    by AccountDomain, AccountName
| where BaselineLogonCount >= MinBaselineLogons  // Filter accounts with insufficient baseline
| extend
    BaselineDeviceCount = array_length(BaselineDevices),
    HasEstablishedPattern = datetime_diff('day', LastSeen, FirstSeen) >= 7;  // At least 1 week of activity

// --- Module 2: Detect Anomalous Service Account Logons ---
let AnomalousLogons = DeviceLogonEvents
| where TimeGenerated >= ago(DetectionWindow)
| where ActionType == "LogonSuccess"
| extend AccountLower = tolower(AccountName)
// Identify service accounts
| where AccountLower has_any (ServiceAccountPrefixes)
    or AccountLower has_any (ServiceAccountSuffixes)
    or AccountName in~ (BuiltInServiceAccounts)
    or AccountName endswith "$"
| join kind=inner (CurrentDevices) on DeviceId
| extend
    LogonHour = hourofday(TimeGenerated),
    IsOffHours = LogonHour >= OffHoursStart or LogonHour <= OffHoursEnd
// Join with baseline
| join kind=leftouter (ServiceAccountBaseline) on AccountDomain, AccountName
| extend
    // Determine if this is a new device
    IsNewDevice = DeviceId !in (coalesce(BaselineDeviceIds, dynamic([]))),
    HasBaseline = isnotnull(BaselineDeviceCount),
    IsNewDeviceType = DeviceCategory !in (coalesce(BaselineDeviceTypes, dynamic([]))),
    IsUnusualLogonType = LogonType !in (coalesce(CommonLogonTypes, dynamic([]))),
    IsUnusualHour = LogonHour !in (coalesce(CommonHours, dynamic([])))
| where IsNewDevice and HasBaseline  // Core detection: new device with existing baseline
| extend
    RemoteDeviceCount = tostring(RemoteDeviceCount),
    RemoteIP = tostring(RemoteIP),
    RemotePort = tostring(RemotePort)
| project TimeGenerated, AccountDomain, AccountName, DeviceId, DeviceName, DeviceCategory,
          IsWorkstation, IsServer, IsDomainController, LogonType, RemoteDeviceCount, RemoteIP,
          RemotePort, IsOffHours, IsNewDevice, IsNewDeviceType, IsUnusualLogonType,
          BaselineDeviceCount, BaselineDevices, BaselineLogonCount, LogonId;

// --- Module 3: Failed Logon Correlation ---
let FailedLogons = DeviceLogonEvents
| where TimeGenerated >= ago(DetectionWindow)
| where ActionType == "LogonFailed"
| extend AccountLower = tolower(AccountName)
| where AccountLower has_any (ServiceAccountPrefixes)
    or AccountLower has_any (ServiceAccountSuffixes)
    or AccountName endswith "$"
| summarize
    FailedAttempts = count(),
    FailedDevices = make_set(DeviceName),
    FirstFailure = min(TimeGenerated),
    LastFailure = max(TimeGenerated)
    by AccountDomain, AccountName, bin(TimeGenerated, 1h);

let LogonsWithFailures = AnomalousLogons
| join kind=leftouter (
    FailedLogons
    | extend JoinTime = bin(TimeGenerated, 1h)
) on AccountDomain, AccountName, $left.TimeGenerated == $right.JoinTime
| extend
    HadRecentFailures = isnotnull(FailedAttempts),
    FailedAttempts = coalesce(FailedAttempts, 0),
    FailureToSuccessSeconds = iff(isnotnull(FirstFailure), datetime_diff('second', TimeGenerated, LastFailure), 0);

// --- Module 4: Velocity Analysis (Rapid Successive Logons) ---
let VelocityAnalysis = AnomalousLogons
| extend AccountKey = strcat(AccountDomain, "\\", AccountName)
| order by AccountKey, TimeGenerated asc
| extend PreviousLogonTime = prev(TimeGenerated, 1)
| extend TimeDelta = datetime_diff('second', TimeGenerated, PreviousLogonTime)
| where TimeDelta <= 300  // Within 5 minutes
| summarize
    RapidLogonCount = count(),
    RapidTargetDevices = make_set(DeviceName),
    RapidLogonSpan = datetime_diff('second', max(TimeGenerated), min(TimeGenerated))
    by AccountDomain, AccountName, bin(TimeGenerated, VelocityWindow);

let LogonsWithVelocity = LogonsWithFailures
| join kind=leftouter (VelocityAnalysis) 
    on AccountDomain, AccountName
| extend
    RapidLogonCount = coalesce(RapidLogonCount, 0),
    IsSprayPattern = RapidLogonCount >= 3;

// --- Module 5: Privileged Account Context ---
let PrivilegedAccounts = IdentityInfo
| where TimeGenerated >= ago(7d)
| where AssignedRoles has_any (PrivilegedGroups)
| summarize
    PrivilegedRoles = make_set(AssignedRoles),
    IsPrivileged = true
    by AccountDomain, AccountName = tolower(AccountUpn);

let LogonsWithPrivilegeContext = LogonsWithVelocity
| join kind=leftouter (PrivilegedAccounts)
    on AccountDomain, $left.AccountName == $right.AccountName
| extend
    IsPrivileged = coalesce(IsPrivileged, false),
    PrivilegedRoles = coalesce(PrivilegedRoles, dynamic([]));

// --- Module 6: Source Device Analysis ---
let SourceDeviceContext = DeviceLogonEvents
| where TimeGenerated >= ago(DetectionWindow)
| where ActionType == "LogonSuccess"
| extend SourceDevice = RemoteDeviceName
| where isnotempty(SourceDevice)
| join kind=inner (CurrentDevices) on $left.SourceDevice == $right.DeviceName
| summarize
    SourceDeviceCategory = any(DeviceCategory),
    SourceIsWorkstation = any(IsWorkstation)
    by LogonId;

let LogonsWithSourceContext = LogonsWithPrivilegeContext
| join kind=leftouter (SourceDeviceContext) on LogonId
| extend
    SourceDeviceCategory = coalesce(SourceDeviceCategory, "Unknown"),
    SourceIsWorkstation = coalesce(SourceIsWorkstation, false);

// --- Module 7: Lateral Movement Pattern Detection ---
let LateralMovementPatterns = LogonsWithSourceContext
| extend AccountKey = strcat(AccountDomain, "\\", AccountName)
| summarize
    UniqueTargets = dcount(DeviceName),
    TargetDevices = make_set(DeviceName),
    TargetCategories = make_set(DeviceCategory),
    HasDCTarget = max(toint(IsDomainController)),
    HasWorkstationTarget = max(toint(IsWorkstation)),
    FirstLogon = min(TimeGenerated),
    LastLogon = max(TimeGenerated)
    by AccountKey, AccountDomain, AccountName, bin(TimeGenerated, 1h)
| where UniqueTargets >= 3  // Logged onto 3+ different devices in 1 hour
| extend
    LateralMovementSpan = datetime_diff('minute', LastLogon, FirstLogon),
    Signal = "Lateral_Movement_Pattern";

// --- Consolidate All Detections ---
let AllDetections = LogonsWithSourceContext
| extend
    IsPrivileged = coalesce(IsPrivileged, false),
    HadRecentFailures = coalesce(HadRecentFailures, false),
    IsSprayPattern = coalesce(IsSprayPattern, false),
    FailedAttempts = coalesce(FailedAttempts, 0);

let FinalDetections = union isfuzzy=true
    (AllDetections | extend Signal = "New_Device_Logon"),
    (LateralMovementPatterns | extend Signal = "Lateral_Movement_Pattern")
| extend
    IsWorkstation = coalesce(IsWorkstation, false),
    IsDomainController = coalesce(IsDomainController, false),
    IsOffHours = coalesce(IsOffHours, false),
    IsNewDeviceType = coalesce(IsNewDeviceType, false),
    IsUnusualLogonType = coalesce(IsUnusualLogonType, false),
    BaselineDeviceCount = coalesce(BaselineDeviceCount, 0),
    UniqueTargets = coalesce(UniqueTargets, 1);

// --- Risk Scoring ---
FinalDetections
| extend
    BaseRisk = case(
        Signal == "Lateral_Movement_Pattern", 90,
        LogonType in ("10", "RemoteInteractive"), 85,      // RDP logon
        LogonType in ("3", "Network"), 75,                  // Network logon (common LM)
        LogonType in ("2", "Interactive"), 70,
        60
    ),
    TargetBonus =
        iff(IsDomainController, 30, 0)                      // DC access = critical
        + iff(IsWorkstation and not(DeviceName has_any (AdminWorkstations)), 20, 0)  // User workstation
        + iff(IsNewDeviceType, 10, 0)                       // New device type
        + iff(BaselineDeviceCount <= 5, 10, 0),            // Low baseline (account rarely used)
    ContextBonus =
        iff(IsPrivileged, 25, 0)                           // Privileged account
        + iff(HadRecentFailures, 20, 0)                    // Failed attempts before success
        + iff(IsSprayPattern, 15, 0)                       // Rapid successive logons
        + iff(IsOffHours, 10, 0)                           // Off-hours activity
        + iff(IsUnusualLogonType, 10, 0)                   // Unusual logon type for this account
        + iff(UniqueTargets >= 5, 20, 0)                   // High lateral movement
        + iff(SourceIsWorkstation, 10, 0),                 // Originating from workstation
    TotalRiskScore = BaseRisk + TargetBonus + ContextBonus
| extend
    AlertSeverity = case(
        TotalRiskScore >= 110, "Critical",
        TotalRiskScore >= 85, "High",
        TotalRiskScore >= 65, "Medium",
        "Low"
    )
| where AlertSeverity in ("Critical", "High", "Medium")
| extend
    Evidence = bag_pack(
        "Signal", Signal,
        "Account", strcat(AccountDomain, "\\", AccountName),
        "TargetDevice", coalesce(DeviceName, "Multiple"),
        "DeviceCategory", coalesce(DeviceCategory, "Multiple"),
        "LogonType", LogonType,
        "BaselineDevices", BaselineDeviceCount,
        "IsPrivileged", IsPrivileged,
        "PrivilegedRoles", PrivilegedRoles,
        "IsDomainController", IsDomainController,
        "IsWorkstation", IsWorkstation,
        "IsOffHours", IsOffHours,
        "HadRecentFailures", HadRecentFailures,
        "FailedAttempts", FailedAttempts,
        "RapidLogons", IsSprayPattern,
        "UniqueTargets", UniqueTargets,
        "TargetDevices", coalesce(TargetDevices, BaselineDevices),
        "RemoteIP", RemoteIP
    ),
    MITRETechniques = case(
        Signal == "Lateral_Movement_Pattern", "T1078.002 (Valid Accounts: Domain Accounts), T1021 (Remote Services), T1570 (Lateral Tool Transfer)",
        IsDomainController, "T1078.002 (Valid Accounts: Domain Accounts), T1021.002 (SMB/Windows Admin Shares)",
        LogonType in ("10", "RemoteInteractive"), "T1021.001 (Remote Desktop Protocol)",
        LogonType == "3", "T1021.002 (SMB/Windows Admin Shares)",
        "T1078.002 (Valid Accounts: Domain Accounts), T1021 (Remote Services)"
    ),
    RecommendedActions = case(
        AlertSeverity == "Critical", "IMMEDIATE: Isolate both source and target devices. Reset service account credentials. Investigate for Pass-the-Hash/Pass-the-Ticket. Check for data exfiltration and persistence mechanisms. Review all recent activity by this account.",
        AlertSeverity == "High", "URGENT: Validate service account logon legitimacy. Check if account credentials are compromised. Review source device for malware. Investigate for lateral movement indicators. Consider credential reset if unauthorized.",
        "Review logon context and validate against service account expected behavior. Check for configuration changes or new application deployments that might explain the activity."
    )
| project
    TimeGenerated = coalesce(TimeGenerated, FirstLogon),
    AlertSeverity,
    TotalRiskScore,
    Signal,
    ServiceAccount = strcat(AccountDomain, "\\", AccountName),
    TargetDevice = coalesce(DeviceName, strcat(tostring(UniqueTargets), " devices")),
    TargetDeviceCategory = coalesce(DeviceCategory, "Multiple"),
    LogonType,
    IsDomainController = coalesce(IsDomainController, HasDCTarget == 1),
    IsPrivileged,
    BaselineDeviceCount,
    FailedAttempts,
    UniqueTargets,
    Evidence,
    MITRETechniques,
    RecommendedActions
| sort by TotalRiskScore desc, TimeGenerated desc

references:
  - https://attack.mitre.org/techniques/T1078/002/
  - https://attack.mitre.org/techniques/T1021/
  - https://attack.mitre.org/techniques/T1570/
  - https://web-assets.esetstatic.com/wls/2019/10/ESET_Operation_Ghost_Dukes.pdf
  - https://cloud.google.com/blog/topics/threat-intelligence/suspected-apt-actors-leverage-bypass-techniques-pulse-secure-zero-day/
  - https://web.archive.org/web/20230218064220/https://research.nccgroup.com/2021/01/12/abusing-cloud-services-to-fly-under-the-radar/
  - https://thehackernews.com/2024/09/wherever-theres-ransomware-theres.html

triage: |
  This alert means a service account is logging onto a host it has never accessed before, potentially using compromised credentials (Pass-the-Hash/Ticket, or credential harvesting).
    1. IMMEDIATE Containment & Account Disruption
      •	Identify Compromised Account: Record the ServiceAccount.
      •	Isolate Target/Source: Immediately isolate the TargetDevice and any devices listed in TargetDevices (if a Lateral Movement Pattern) and, if the source is known, isolate the source device to stop the spread.
      •	Invalidate Credential (CRITICAL):
        o	If possible, force a password change (long, complex) for the ServiceAccount.
        o	If a gMSA/MSA, investigate the recent key retrieval and update its permissions, or temporarily suspend its usage.
        o	Revoke all Kerberos tickets and force a logoff for the account across all domain controllers.
    2. Forensic Scoping on Target Devices
      •	DC Access: If the alert involved a Domain Controller target, prioritize a full forensic memory and disk analysis of that DC immediately, as the attacker likely retrieved the NTDS.dit or golden ticket material.
      •	Target Activity: On the TargetDevice (and all devices in TargetDevices):
        o	Review all logons immediately following the anomalous logon for processes spawned by the service account.
        o	Look for execution of credential dumping tools (e.g., Mimikatz, Procdump).
        o	Look for signs of data staging or tool transfer (net use, Admin shares access).
    3. Credential Compromise Root Cause
      •	Source Device Investigation: If a SourceDevice is identified (or if the logon originated from a Workstation), investigate that machine for the root cause:
        o	Was it infected with a keylogger or malware?
        o	Was a local credential dump performed on that device?
        o	If the service account logs onto the source device legitimately, that device is the probable point of initial credential compromise.
      •	Failed Logons/Velocity Check: Use the FailedAttempts and IsSprayPattern flags to confirm the attack type. High failed counts suggest brute force or spraying; a high RapidLogonCount suggests an automated script (like a worm or a built-in attack tool).
    4. Escalation
      •	Escalate: Confirm the incident as a breach involving Lateral Movement and Credential Access. Escalations team should coordinate a domain-wide check for other compromised accounts and ensure the service account is no longer usable by the attacker.

notes: |
  - I attempted an off hours piece of this but frankly that's probably not going to work for this environment.  Be progressive about cutting it off early if it can'be be salvaged.
