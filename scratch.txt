// Enhanced Mailbox Enumeration Detection via Graph API
// Parameters
let TimeWindow = 4h;                    // Analysis window
let ShortTimeWindow = 15m;              // Burst detection window
let BaselineWindow = 7d;                // Historical baseline period
let EnumerationThreshold = 50;          // Operations per burst window
let BaselineMultiplier = 3.0;           // Deviation from baseline
let MinimumOperations = 20;             // Minimum ops to consider suspicious

// Define Graph API operations related to mailbox/user enumeration
let MailboxEnumerationOps = dynamic([
    "Get user",
    "List users", 
    "Get group",
    "List groups",
    "Get mail",
    "List messages",
    "Get message",
    "List mailFolders",
    "Get mailFolder", 
    "List contacts",
    "Get contact",
    "Search messages",
    "List directoryObjects",
    "Get directoryObject",
    "List members",
    "Get member",
    "List transitiveMembers"
]);

// Helper: Get user baselines for comparison
let UserBaselines = 
    AuditLogs
    | where TimeGenerated between (ago(BaselineWindow) .. ago(TimeWindow))
    | where OperationName in (MailboxEnumerationOps)
    | where isnotempty(InitiatedBy.user.userPrincipalName)
    | summarize 
        BaselineOpsPerHour = count() / (BaselineWindow / 1h),
        BaselineDistinctOps = dcount(OperationName),
        BaselineApps = dcount(AppId),
        HistoricalActivity = count()
    by UserPrincipalName = tostring(InitiatedBy.user.userPrincipalName);

// Helper: Identify high-risk applications and contexts
let SuspiciousContext = 
    AuditLogs
    | where TimeGenerated >= ago(TimeWindow)
    | where OperationName in (MailboxEnumerationOps)
    | where isnotempty(InitiatedBy.user.userPrincipalName)
    | extend 
        UserPrincipalName = tostring(InitiatedBy.user.userPrincipalName),
        SourceIP = tostring(InitiatedBy.user.ipAddress),
        AppName = tostring(AppDisplayName),
        UserAgent = tostring(UserAgent)
    // Risk indicators
    | extend 
        IsNewApp = AppName !in ("Microsoft Graph Explorer", "Azure Portal", "PowerShell", "Azure CLI"),
        IsUnusualUA = UserAgent contains "curl" or UserAgent contains "python" or UserAgent contains "PowerShell" or UserAgent == "",
        IsExternalIP = not(ipv4_is_private(SourceIP)) and SourceIP != "",
        HasRiskFlags = RiskState == "atRisk" or RiskLevelAggregated != "none"
    | project-away InitiatedBy;

// Main detection logic
let EnumerationEvents = 
    SuspiciousContext
    | summarize 
        TotalOperations = count(),
        DistinctOperations = dcount(OperationName),
        DistinctTargets = dcount(TargetResources),
        DistinctApps = dcount(AppId),
        UniqueIPs = dcount(SourceIP),
        FirstActivity = min(TimeGenerated),
        LastActivity = max(TimeGenerated),
        Operations = make_set(OperationName, 10),
        Applications = make_set(AppName, 5),
        SourceIPs = make_set(SourceIP, 5),
        UserAgents = make_set(UserAgent, 3),
        // Risk flags
        NewAppCount = countif(IsNewApp),
        UnusualUACount = countif(IsUnusualUA), 
        ExternalIPCount = countif(IsExternalIP),
        RiskFlagCount = countif(HasRiskFlags),
        // Burst analysis
        MaxBurstOps = 0  // Will calculate separately
    by UserPrincipalName, bin(TimeGenerated, ShortTimeWindow)
    | where TotalOperations >= MinimumOperations;

// Calculate burst patterns
let BurstAnalysis = 
    SuspiciousContext
    | summarize BurstOps = count() by UserPrincipalName, bin(TimeGenerated, ShortTimeWindow)
    | summarize 
        MaxBurst = max(BurstOps),
        AvgBurst = avg(BurstOps),
        BurstWindows = count()
    by UserPrincipalName;

// Combine enumeration events with burst analysis and baselines
let CombinedAnalysis = 
    EnumerationEvents
    | summarize 
        TotalOps = sum(TotalOperations),
        MaxDistinctOps = max(DistinctOperations),
        MaxDistinctTargets = max(DistinctTargets),
        TotalApps = max(DistinctApps),
        TotalIPs = max(UniqueIPs),
        ActivityStart = min(FirstActivity),
        ActivityEnd = max(LastActivity),
        AllOperations = make_set(Operations),
        AllApplications = make_set(Applications), 
        AllSourceIPs = make_set(SourceIPs),
        AllUserAgents = make_set(UserAgents),
        TotalNewApps = sum(NewAppCount),
        TotalUnusualUA = sum(UnusualUACount),
        TotalExternalIPs = sum(ExternalIPCount),
        TotalRiskFlags = sum(RiskFlagCount),
        ActiveWindows = count()
    by UserPrincipalName
    | join kind=leftouter (BurstAnalysis) on UserPrincipalName
    | join kind=leftouter (UserBaselines) on UserPrincipalName;

// Apply detection logic with scoring
CombinedAnalysis
| extend 
    // Handle users with no baseline (new accounts)
    BaselineOpsPerHour = iif(isnull(BaselineOpsPerHour), 0.0, BaselineOpsPerHour),
    ExpectedOpsInWindow = BaselineOpsPerHour * (TimeWindow / 1h),
    
    // Calculate anomaly factors
    VolumeAnomaly = iif(ExpectedOpsInWindow > 0, TotalOps / ExpectedOpsInWindow, TotalOps / 10.0),
    BurstAnomaly = iif(isnull(MaxBurst), 1.0, MaxBurst / 10.0),
    
    // Risk scoring
    VolumeScore = case(
        TotalOps > EnumerationThreshold * 2, 30,
        TotalOps > EnumerationThreshold, 20,
        VolumeAnomaly > BaselineMultiplier, 15,
        10
    ),
    
    DiversityScore = case(
        MaxDistinctOps >= 8, 25,        // High operation diversity
        MaxDistinctTargets > 100, 20,   // Many targets accessed
        TotalApps > 3, 15,              // Multiple applications
        10
    ),
    
    BehaviorScore = case(
        TotalNewApps > 0 and TotalUnusualUA > 0, 25,  // New app + unusual UA
        TotalExternalIPs > 0, 20,                      // External IP access
        TotalRiskFlags > 0, 15,                        // Risk flags present
        isnull(HistoricalActivity), 15,                // New user (no history)
        5
    ),
    
    PatternScore = case(
        MaxBurst > EnumerationThreshold, 20,           // High burst activity
        ActiveWindows == 1, 15,                        // All activity in one window
        BurstWindows > 10, 10,                         // Sustained activity
        5
    )

| extend 
    TotalRiskScore = VolumeScore + DiversityScore + BehaviorScore + PatternScore,
    ActivityDuration = datetime_diff('minute', ActivityEnd, ActivityStart)

// Apply thresholds and generate alerts
| where TotalRiskScore >= 50 or TotalOps > EnumerationThreshold

| extend 
    AlertSeverity = case(
        TotalRiskScore >= 80, "Critical",
        TotalRiskScore >= 65, "High", 
        TotalRiskScore >= 50, "Medium",
        "Low"
    ),
    
    // Evidence for investigation
    Evidence = pack(
        "TotalOperations", TotalOps,
        "DistinctOperations", MaxDistinctOps,
        "DistinctTargets", MaxDistinctTargets,
        "ActivityDuration", ActivityDuration,
        "MaxBurst", MaxBurst,
        "VolumeAnomaly", VolumeAnomaly,
        "NewApplications", TotalNewApps,
        "ExternalAccess", TotalExternalIPs > 0,
        "RiskIndicators", TotalRiskFlags
    ),
    
    Recommendations = case(
        TotalRiskScore >= 80, "IMMEDIATE: Disable account, review all recent Graph API access, check for data exfiltration",
        TotalRiskScore >= 65, "URGENT: Verify user identity, review application permissions, monitor for data access",
        TotalRiskScore >= 50, "INVESTIGATE: Confirm legitimate business purpose, review access patterns",
        "MONITOR: Document baseline behavior for future comparison"
    )

| project 
    TimeGenerated = ActivityEnd,
    UserPrincipalName,
    AlertSeverity,
    TotalRiskScore,
    TotalOperations = TotalOps,
    DistinctOperations = MaxDistinctOps,
    DistinctTargets = MaxDistinctTargets,
    ActivityDurationMinutes = ActivityDuration,
    MaxBurstOperations = MaxBurst,
    Applications = AllApplications,
    SourceIPs = AllSourceIPs,
    UserAgents = AllUserAgents,
    Evidence,
    Recommendations

| sort by TotalRiskScore desc



Review the Reason for Triggering

Read the Reason field in the alert to understand why this activity scored as Medium/High/Critical.

Example: “Enumeration activity significantly above baseline with suspicious diversity indicators.”

Contextualize the Evidence

Examine the Evidence list for supporting facts (e.g., new app ID, high distinct target count, bursty execution, external IP).

Cross-check whether these align with expected user/admin activity.

Validate User Context

Verify details from UserContext (display name, UPN, department, user type).

Determine if this user should be performing mailbox queries or if the behavior is unusual for their role.

Corroborate with Environment

Pivot to related logs:

Sign-in logs: unusual geolocation or impossible travel?

Audit logs: subsequent mailbox access/download?

Look for chained suspicious activity (e.g., exfiltration).

Apply Recommendations

Follow the Recommendations guidance in the alert (investigate sign-ins, validate app legitimacy, escalate if bursty and anomalous).

Escalate promptly if the activity matches critical scenarios (new app + external IP + burst).




title: Mailbox Enumeration via GraphAPI
id: 3d8f2c94-2ef0-4f0f-9a12-d1a9138fa89b
description: Detects anomalous mailbox enumeration using GraphAPI, focusing on volume, diversity, behavior, and burst patterns compared to user baselines.
status: experimental
author: Detection Engineering Team
date: 2025-09-05
tags:
  - technique:T1114.002   # Email Collection: Remote Email Collection (GraphAPI)
  - data_source:AzureAD
  - data_source:GraphAPI
severity: High

query: |


triage:
  steps:
    - Review the `Reason` field to understand why the rule triggered.
    - Examine the `Evidence` array to confirm unusual patterns (e.g., new apps, burst activity, external IP).
    - Validate `UserPrincipalName` against expected job role and access needs.
    - Corroborate findings with sign-in logs and audit logs for chained suspicious activity.
    - Follow `Recommendations` guidance and escalate if critical patterns (new app + external IP + burst) are confirmed.
  recommendations:
    - Investigate whether the app or client is legitimate and approved.
    - Review recent sign-ins for geolocation anomalies or risky logins.
    - Assess if the mailbox contents were accessed or exported after enumeration.
    - Escalate if activity appears automated, bursty, or conducted via unrecognized apps/IPs.




v2

// Enhanced Mailbox Enumeration Detection via Graph API
// Parameters
let TimeWindow = 4h;                    // Analysis window
let ShortTimeWindow = 15m;              // Burst detection window
let BaselineWindow = 7d;                // Historical baseline period
let EnumerationThreshold = 50;          // Operations per burst window
let BaselineMultiplier = 3.0;           // Deviation from baseline
let MinimumOperations = 20;             // Minimum ops to consider suspicious

// Define Graph API operations related to mailbox/user enumeration
let MailboxEnumerationOps = dynamic([
    "Get user",
    "List users", 
    "Get group",
    "List groups",
    "Get mail",
    "List messages",
    "Get message",
    "List mailFolders",
    "Get mailFolder", 
    "List contacts",
    "Get contact",
    "Search messages",
    "List directoryObjects",
    "Get directoryObject",
    "List members",
    "Get member",
    "List transitiveMembers"
]);

// Helper: Get user baselines for comparison
let UserBaselines = 
    AuditLogs
    | where TimeGenerated between (ago(BaselineWindow) .. ago(TimeWindow))
    | where OperationName in (MailboxEnumerationOps)
    | where isnotempty(InitiatedBy.user.userPrincipalName)
    | summarize 
        BaselineOpsPerHour = count() / (BaselineWindow / 1h),
        BaselineDistinctOps = dcount(OperationName),
        BaselineApps = dcount(AppId),
        HistoricalActivity = count()
    by UserPrincipalName = tostring(InitiatedBy.user.userPrincipalName);

// Helper: Identify high-risk applications and contexts
let SuspiciousContext = 
    AuditLogs
    | where TimeGenerated >= ago(TimeWindow)
    | where OperationName in (MailboxEnumerationOps)
    | where isnotempty(InitiatedBy.user.userPrincipalName)
    | extend 
        UserPrincipalName = tostring(InitiatedBy.user.userPrincipalName),
        SourceIP = tostring(InitiatedBy.user.ipAddress),
        AppName = tostring(AppDisplayName),
        UserAgent = tostring(UserAgent)
    // Risk indicators
    | extend 
        IsNewApp = AppName !in ("Microsoft Graph Explorer", "Azure Portal", "PowerShell", "Azure CLI"),
        IsUnusualUA = UserAgent contains "curl" or UserAgent contains "python" or UserAgent contains "PowerShell" or UserAgent == "",
        IsExternalIP = not(ipv4_is_private(SourceIP)) and SourceIP != "",
        HasRiskFlags = RiskState == "atRisk" or RiskLevelAggregated != "none"
    | project-away InitiatedBy;

// Main detection logic
let EnumerationEvents = 
    SuspiciousContext
    | summarize 
        TotalOperations = count(),
        DistinctOperations = dcount(OperationName),
        DistinctTargets = dcount(TargetResources),
        DistinctApps = dcount(AppId),
        UniqueIPs = dcount(SourceIP),
        FirstActivity = min(TimeGenerated),
        LastActivity = max(TimeGenerated),
        Operations = make_set(OperationName, 10),
        Applications = make_set(AppName, 5),
        SourceIPs = make_set(SourceIP, 5),
        UserAgents = make_set(UserAgent, 3),
        // Risk flags
        NewAppCount = countif(IsNewApp),
        UnusualUACount = countif(IsUnusualUA), 
        ExternalIPCount = countif(IsExternalIP),
        RiskFlagCount = countif(HasRiskFlags),
        // Burst analysis
        MaxBurstOps = 0  // Will calculate separately
    by UserPrincipalName, bin(TimeGenerated, ShortTimeWindow)
    | where TotalOperations >= MinimumOperations;

// Calculate burst patterns
let BurstAnalysis = 
    SuspiciousContext
    | summarize BurstOps = count() by UserPrincipalName, bin(TimeGenerated, ShortTimeWindow)
    | summarize 
        MaxBurst = max(BurstOps),
        AvgBurst = avg(BurstOps),
        BurstWindows = count()
    by UserPrincipalName;

// Combine enumeration events with burst analysis and baselines
let CombinedAnalysis = 
    EnumerationEvents
    | summarize 
        TotalOps = sum(TotalOperations),
        MaxDistinctOps = max(DistinctOperations),
        MaxDistinctTargets = max(DistinctTargets),
        TotalApps = max(DistinctApps),
        TotalIPs = max(UniqueIPs),
        ActivityStart = min(FirstActivity),
        ActivityEnd = max(LastActivity),
        AllOperations = make_set(Operations),
        AllApplications = make_set(Applications), 
        AllSourceIPs = make_set(SourceIPs),
        AllUserAgents = make_set(UserAgents),
        TotalNewApps = sum(NewAppCount),
        TotalUnusualUA = sum(UnusualUACount),
        TotalExternalIPs = sum(ExternalIPCount),
        TotalRiskFlags = sum(RiskFlagCount),
        ActiveWindows = count()
    by UserPrincipalName
    | join kind=leftouter (BurstAnalysis) on UserPrincipalName
    | join kind=leftouter (UserBaselines) on UserPrincipalName;

// Apply detection logic with scoring
CombinedAnalysis
| extend 
    // Handle users with no baseline (new accounts)
    BaselineOpsPerHour = iif(isnull(BaselineOpsPerHour), 0.0, BaselineOpsPerHour),
    ExpectedOpsInWindow = BaselineOpsPerHour * (TimeWindow / 1h),
    
    // Calculate anomaly factors
    VolumeAnomaly = iif(ExpectedOpsInWindow > 0, TotalOps / ExpectedOpsInWindow, TotalOps / 10.0),
    BurstAnomaly = iif(isnull(MaxBurst), 1.0, MaxBurst / 10.0),
    
    // Risk scoring
    VolumeScore = case(
        TotalOps > EnumerationThreshold * 2, 30,
        TotalOps > EnumerationThreshold, 20,
        VolumeAnomaly > BaselineMultiplier, 15,
        10
    ),
    
    DiversityScore = case(
        MaxDistinctOps >= 8, 25,        // High operation diversity
        MaxDistinctTargets > 100, 20,   // Many targets accessed
        TotalApps > 3, 15,              // Multiple applications
        10
    ),
    
    BehaviorScore = case(
        TotalNewApps > 0 and TotalUnusualUA > 0, 25,  // New app + unusual UA
        TotalExternalIPs > 0, 20,                      // Anomalous IP access
        TotalRiskFlags > 0, 15,                        // Risk flags present
        isnull(HistoricalActivity), 15,                // New user (no history)
        5
    ),
    
    PatternScore = case(
        MaxBurst > EnumerationThreshold, 20,           // High burst activity
        ActiveWindows == 1, 15,                        // All activity in one window
        BurstWindows > 10, 10,                         // Sustained activity
        5
    )

| extend 
    TotalRiskScore = VolumeScore + DiversityScore + BehaviorScore + PatternScore,
    ActivityDuration = datetime_diff('minute', ActivityEnd, ActivityStart)

// Apply thresholds and generate alerts
| where TotalRiskScore >= 50 or TotalOps > EnumerationThreshold

| extend 
    AlertSeverity = case(
        TotalRiskScore >= 80, "Critical",
        TotalRiskScore >= 65, "High", 
        TotalRiskScore >= 50, "Medium",
        "Low"
    ),
    
    // Evidence for investigation
    Evidence = pack(
        "TotalOperations", TotalOps,
        "DistinctOperations", MaxDistinctOps,
        "DistinctTargets", MaxDistinctTargets,
        "ActivityDuration", ActivityDuration,
        "MaxBurst", MaxBurst,
        "VolumeAnomaly", VolumeAnomaly,
        "NewApplications", TotalNewApps,
        "ExternalAccess", TotalExternalIPs > 0,
        "RiskIndicators", TotalRiskFlags
    ),
    
    Recommendations = case(
        TotalRiskScore >= 80, "IMMEDIATE: Disable account, review all recent Graph API access, check for data exfiltration",
        TotalRiskScore >= 65, "URGENT: Verify user identity, review application permissions, monitor for data access",
        TotalRiskScore >= 50, "INVESTIGATE: Confirm legitimate business purpose, review access patterns",
        "MONITOR: Document baseline behavior for future comparison"
    )

| project 
    TimeGenerated = ActivityEnd,
    UserPrincipalName,
    AlertSeverity,
    TotalRiskScore,
    TotalOperations = TotalOps,
    DistinctOperations = MaxDistinctOps,
    DistinctTargets = MaxDistinctTargets,
    ActivityDurationMinutes = ActivityDuration,
    MaxBurstOperations = MaxBurst,
    Applications = AllApplications,
    SourceIPs = AllSourceIPs,
    UserAgents = AllUserAgents,
    Evidence,
    Recommendations

| sort by TotalRiskScore desc




/////////////////////////////////////////////////////////////////



Detection Modernization & Coverage Prioritization Framework
Context: Technical Debt + Coverage Gaps + Active Threat Response
Assumption: All rules under consideration have <10% false positive rate
Primary Scoring Factors
1. Threat Severity & Impact (25%)
What happens if this attack succeeds?
•	5 - Business Critical: Complete disruption, regulatory fines, brand destruction
•	4 - High Impact: Significant revenue loss, data breach, operational shutdown
•	3 - Medium Impact: Service degradation, limited data exposure
•	2 - Low Impact: Minor disruption, easily contained
•	1 - Minimal Impact: Nuisance level, no meaningful consequence
2. Attack Prevalence & Likelihood (25%)
How likely is this to happen to us?
•	5 - Imminent: Daily/weekly attempts, active campaigns targeting our sector
•	4 - High Probability: Monthly observations, common in our industry
•	3 - Moderate: Quarterly sightings, general threat landscape
•	2 - Low Probability: Annual occurrences, specific conditions required
•	1 - Very Low: Rare/theoretical, not observed in similar environments
3. Coverage Gap Value (30%)
How much does this improve our detection posture?
•	5 - Critical Gap: Zero detection for entire MITRE tactic, major blind spot
•	4 - Important Gap: First detection for high-risk technique, fills sub-technique void
•	3 - Moderate Gap: Improves detection for partially covered technique
•	2 - Minor Gap: Adds alternative detection method, provides redundancy
•	1 - No Gap: Overlaps with existing high-quality detection
4. Threat Intelligence Urgency (20%)
How current and specific is the threat intelligence?
•	5 - Active Campaign: Currently targeting our sector (last 30 days)
•	4 - Recent Intelligence: Mentioned in recent reports for our industry (last 90 days)
•	3 - Current Intelligence: Present in general threat feeds (last 6 months)
•	2 - Historical Intelligence: Previously observed, not currently active
•	1 - No Intelligence: Limited or outdated threat intelligence

Scoring Formula
Priority Score = (Threat Severity × 0.25) + (Attack Prevalence × 0.25) + 
                (Coverage Gap Value × 0.30) + (Threat Intel Urgency × 0.20)


Coverage Gap Assessment Matrix
Step 1: Map Your Current Detection Coverage
// Example coverage audit query
AuditLogs
| where TimeGenerated > ago(30d)
| summarize DetectedTechniques = make_set(MitreTechnique) by DetectionRuleName
| project DetectionRuleName, CoveredTechniques = array_length(DetectedTechniques)
Step 2: Identify MITRE ATT&CK Gaps
Tactic	Current Coverage	Critical Gaps	Priority Boost
Initial Access	40%	T1190 (Exploit Public App), T1566 (Phishing)	High
Execution	80%	T1059.001 (PowerShell), T1204 (User Execution)	Medium
Persistence	20%	T1053 (Scheduled Tasks), T1547 (Boot Autostart)	Critical
Privilege Escalation	30%	T1068 (Exploitation), T1134 (Token Manipulation)	Critical
Defense Evasion	60%	T1070 (Indicator Removal), T1055 (Process Injection)	High
Credential Access	70%	T1003 (Credential Dumping), T1110 (Brute Force)	Medium
Discovery	10%	T1087 (Account Discovery), T1083 (File Discovery)	Critical
Lateral Movement	50%	T1021 (Remote Services), T1570 (Tool Transfer)	High
Collection	15%	T1005 (Local Data), T1039 (Archive Collection)	Critical
Exfiltration	25%	T1041 (C2 Channel), T1048 (Alternative Protocols)	Critical
Step 3: Coverage Gap Scoring Logic
Gap Value = Base Score + Tactic Coverage Bonus + Technique Rarity Bonus

Base Score:
- 5: Zero detection for entire tactic (<20% coverage)
- 4: First detection for important technique (20-40% coverage)  
- 3: Improving existing weak coverage (40-60% coverage)
- 2: Adding redundancy to good coverage (60-80% coverage)
- 1: Overlapping strong coverage (>80% coverage)

Tactic Coverage Bonus:
- +1 if tactic has <30% coverage
- +0.5 if tactic has <50% coverage

Technique Rarity Bonus:
- +1 if technique appears in <3 existing rules
- +0.5 if technique appears in <5 existing rules



Ongoing: Monthly review of threat intelligence to identify new high-priority gaps
This framework should help you systematically eliminate blind spots while staying responsive to active threats and cleaning up technical debt - exactly what you need for a comprehensive detection modernization effort.



